








namespace _detail
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

using namespace _retail::_detail;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

template <class       W >	using            member_t = typename _xtd::decay_non_nominal_reference<W>::value_type;
template <class    ...Ws>	concept          member_q =     molecular_q<Ws...>;
template <class    ...Ws>	concept       dismember_q = not molecular_q<Ws...>;
///\
Resolves/dereferences the current value. \

template <pointed_q   M >	XTAL_DEF_(return,inline,let) remember_f(M &&m) noexcept -> decltype(auto) {return *XTAL_REF_(m);}
template <class       M >	XTAL_DEF_(return,inline,let) remember_f(M &&m) noexcept -> decltype(auto) {return  XTAL_REF_(m);}
///\
Constructs/references the current value. \

template <dismember_q M >	XTAL_DEF_(return,inline,let)   member_f(auto &&    o) noexcept -> decltype(auto) {return             &  XTAL_REF_(o )    ;}
template <   number_q M >	XTAL_DEF_(return,inline,let)   member_f(auto &&    o) noexcept -> decltype(auto) {return static_cast<M>(XTAL_REF_(o ))   ;}
template <class       M >	XTAL_DEF_(return,inline,let)   member_f(auto &&...oo) noexcept -> decltype(auto) {return             M (XTAL_REF_(oo)...);}
///\
Replaces and returns the previous value. \

template <member_q W>
XTAL_DEF_(return,inline,let)
dismember_f(W &m, W w)
noexcept -> decltype(auto)
{
	return _std::exchange(m, XTAL_MOV_(w));
}
template <member_q W>
XTAL_DEF_(return,inline,let)
dismember_f(W &m, auto &&...x)
noexcept -> decltype(auto)
{
	return thunk_f(XTAL_MOV_(m)) (new (&m) based_t<W>(XTAL_REF_(x)...));
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

template <class T>
struct define_super
{
	using superkind = _retail::define<T>;

	template <class S>
	class subtype : public bond::compose_s<S, superkind, navigate<>>
	{
		using S_ = bond::compose_s<S, superkind, navigate<>>;
	
	public:// CONSTRUCT
		using S_::S_;

		XTAL_NEW_(cast) (subtype, noexcept)

		XTAL_NEW_(explicit)
		subtype(auto &&...oo)
		noexcept
		:	S_(XTAL_REF_(oo)...)
		{}

	public:// ACCESS
		using S_::self;

		XTAL_FX4_(do) (template <fungible_q<subtype> Y=T>
		XTAL_DEF_(return,inline,let)
		self(auto &&...oo),
		noexcept -> decltype(auto)
		{
			auto  x = self<Y>();
			auto &y = self<Y>(); y.~ Y();
			return *new (&y) Y(XTAL_REF_(oo)..., XTAL_MOV_(x));
		})

		template <class ...Is>
		struct super : bond::seek_back<Is...> {};

		XTAL_DEF_(return,inline,let)
		pack() const
		{
			return bond::pack_f();
		}
		///<\returns a tuple representation of `this`. \

		using pack_size = cardinal_constant_t<0>;
		///< The `std::tuple_size` of `this`. \


	};
};


///////////////////////////////////////////////////////////////////////////////

template <class T>
struct refine_head
{
	template <class S>
	class subtype : public S
	{
	public:
		using S::S; static_assert(any_q<S>);

	};
	template <class S> requires (1 == typename S::pack_size{}())
	class subtype<S> : public S
	{
	public:
		using S::S; static_assert(any_q<S>);
		///\
		Implicit conversion to the singleton kernel-type. \

		XTAL_FX4_(to) (XTAL_DEF_(return,inline,implicit)
		operator typename S::head_type(), S::head())

	};
};
template <class T>
struct refine_tuple
{
	template <class S>
	class subtype : public S
	{
	public:
		using S::S; static_assert(any_q<S>);
		using typename S::pack_size;

		///\
		Tuple application. \

		XTAL_FX2_(do) (XTAL_DEF_(inline,let)
		apply(auto &&f),
		noexcept -> decltype(auto)
		{
			XTAL_IF0
			XTAL_0IF (0 == pack_size{}()) {
				return XTAL_REF_(f) ();
			}
			XTAL_0IF (1 <= pack_size{}()) {
				return [this, f=XTAL_REF_(f)] <auto ...I>(bond::seek_t<I...>)
					XTAL_0FN_(to) (f(S::template head<I>()...))
				(bond::seek_s<pack_size{}()> {});
			}
		})
		template <auto  f=[] XTAL_1FN_(function) (bond::pack_f)>
		XTAL_DEF_(return,inline,let)
		apply() const
		noexcept -> decltype(auto)
		{
			return apply(constant_t<f>{});
		}
		template <class F>
		XTAL_DEF_(return,inline,let)
		apply() const
		noexcept -> decltype(auto)
		{
			return apply<evoke_t<F>{}>();
		}

		///\
		Sequence conversion. \

		XTAL_DEF_(return,inline,let)
		seek() const
		{
			return apply<[] XTAL_1FN_(function) (bond::seek_f)>();
		}
		
		///\
		Tuple conversion. \

		XTAL_DEF_(return,inline,implicit)
		operator bond::repack_t<S>() const {return pack();}

		XTAL_DEF_(return,inline,let)
		pack() const
		{
			return apply<[] XTAL_1FN_(function) (bond::pack_f)>();
		}
		
		XTAL_DEF_(return,inline,set)
		unpack_f(bond::pack_q auto const &tuple)
		noexcept -> T
		{
			return _std::apply([] XTAL_1FN_(function) (T), tuple);
		}

	};
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

template <class U>
struct defer_field
{
	template <class S>
	class subtype : public bond::compose_s<S>
	{
		static_assert(any_q<S>);
		using S_ = bond::compose_s<S>;
		using U_ = initializer_u<U>;

	public:
		using head_type = U;
		using body_type = member_t<U>;

	public:
		//\
		Public visibility allows `auto` parameterization in templates.

		body_type body_part;

	public:
	//	using S_::S_;
		
		XTAL_NEW_(delete) (subtype, noexcept = default)
//		XTAL_NEW_(create) (subtype, noexcept = default)
		XTAL_NEW_(move)   (subtype, noexcept = default)
		XTAL_NEW_(copy)   (subtype, noexcept = default)
		XTAL_NEW_(cast)   (subtype, noexcept)

		///\
		Constructs `this` using the default value. \

		XTAL_NEW_(implicit)
		subtype()
		noexcept
		:	subtype(body_type{})
		{}
		///\
		Constructs `this` using an `initializer_list` if supported. \

		XTAL_NEW_(implicit)
		subtype(_std::initializer_list<U_> o)
		noexcept
		requires member_q<U> and initializer_q<U>
		:	body_part(o)
		{}
		///\
		Constructs `this` using the first argument, forwarding the rest to the parent. \

		XTAL_NEW_(explicit)
		subtype(auto &&o, auto &&...oo)
		noexcept
		:	S_(XTAL_REF_(oo)...)
		,	body_part(member_f<head_type>(XTAL_REF_(o)))
		{}

		///\returns the kernel-body (prior to reconstruction using the given arguments, if provided). \

		XTAL_DEF_(return,inline,let) head() const  & noexcept -> decltype(auto) {return remember_f(body_part);}
		XTAL_DEF_(return,inline,let) head()        & noexcept -> decltype(auto) {return remember_f(body_part);}
		XTAL_DEF_(return,inline,let) head() const && noexcept -> decltype(auto) {return remember_f(XTAL_MOV_(body_part));}
		XTAL_DEF_(return,inline,let) head()       && noexcept -> decltype(auto) {return remember_f(XTAL_MOV_(body_part));}
		
		XTAL_DEF_(inline,let)
		head(auto &&...oo)
		noexcept -> decltype(auto)
		requires member_q<head_type> and (0 < sizeof...(oo))
		{
			return dismember_f(body_part, XTAL_REF_(oo)...);
		}

		///\returns the underlying `cardinal` for indexing purposes. \

		XTAL_DEF_(return,inline,explicit)
		operator size_type() const
		noexcept requires cardinal_q<body_type> and different_q<size_type, head_type>
		{
			return body_part;
		}

		XTAL_DEF_(return,inline,set)
		cardinality()
		noexcept -> size_type
		requires XTAL_TRY_(return) (S_::cardinality())

		XTAL_DEF_(return,inline,set)
		cardinality()
		noexcept -> size_type
		requires in_n<typename S_::pack_size{}(), 0> and same_q<bool, U>
		{
			return 2;
		}

	};
};
template <constant_q U>
struct defer_field<U>
{
	template <class S>
	class subtype : public bond::compose_s<S>
	{
		static_assert(any_q<S>);
		using S_ = bond::compose_s<S>;

	public:
		using head_type = U;
		using body_type = member_t<U>;

	public:
		using S_::S_;
		using S_::self;
		body_type body_part{};

		template <constant_q K>
		XTAL_NEW_(explicit)
		subtype(K, auto &&...oo)
		noexcept
		:	S_(XTAL_REF_(oo)...)
		{
			static_assert(K{}() == U{}());
		}

		///\returns the kernel-body (prior to reconstruction using the given arguments, if provided). \

	//	static head_type constexpr head{};
		XTAL_DEF_(return,inline,let) head() const noexcept -> head_type const & requires      member_q<U>  {return             body_part;}
		XTAL_DEF_(return,inline,let) head() const noexcept -> head_type         requires un_n<member_q<U>> {return (head_type) body_part;}
		
	};
};
template <class I, auto ...Ns>
struct defer_field<_std::integer_sequence<I, Ns...>>
{
	using _fit = bond::fit<decltype(Ns)...>;

	static auto constexpr N_coordinate = bond::seek_value_t<Ns...>{};
	static auto constexpr N_ordinate   = bond::seek_index_t<Ns...>{};

	template <class S>
	class subtype : public bond::compose_s<S>
	{
		static_assert(any_q<S>);
		using S_ = bond::compose_s<S>;

	public:
		using head_type = _std::make_signed_t<I>;
		using body_type = size_type;

	public:
	//	using S_::S_;
		using S_::self;
		body_type body_part{};

		XTAL_NEW_(delete) (subtype, noexcept = default)
		XTAL_NEW_(create) (subtype, noexcept = default)
		XTAL_NEW_(move)   (subtype, noexcept = default)
		XTAL_NEW_(copy)   (subtype, noexcept = default)
		XTAL_NEW_(cast)   (subtype, noexcept)
		
		XTAL_NEW_(explicit)
		subtype(infungible_q<subtype> auto &&o, auto &&...oo)
		noexcept
		requires un_n<integral_q<decltype(o)>>
		:	subtype(static_cast<head_type>(XTAL_REF_(o)), XTAL_REF_(oo)...)
		{
		}
		XTAL_NEW_(explicit)
		subtype( ordinal_q auto &&o, auto &&...oo)
		noexcept
		:	subtype(static_cast<body_type>(N_ordinate[XTAL_REF_(o)]), XTAL_REF_(oo)...)
		{
		}
		XTAL_NEW_(explicit)
		subtype(cardinal_q auto &&o, auto &&...oo)
		noexcept
		:	S_(XTAL_REF_(oo)...)
		,	body_part(XTAL_REF_(o))
		{
		}

		XTAL_DEF_(return,inline,set)
		cardinality()
		noexcept -> auto
		{
			return sizeof...(Ns);
		}
		
		XTAL_DEF_(return,inline,let)
		head() const
		noexcept -> auto
		{
			return N_coordinate[body_part];
		}
		
		XTAL_FX1_(to) (XTAL_DEF_(return,inline,explicit)
		operator size_type(), body_part)

	};
};
template <size_type N_width>
struct defer_field<unit_type[N_width]>
{
	static_assert(0 < N_width);
	using U = unit_type[N_width];

	static unsigned constexpr N_depth = _std::bit_width(N_width - one);
	static_assert(N_width == one << N_depth);

	using superkind = bond::word<N_width>;

	template <class S>
	class subtype : public bond::compose_s<S, superkind>
	{
		static_assert(any_q<S>);
		using S_ = bond::compose_s<S, superkind>;

	public:
		using head_type = unsigned;
		using body_type = unsigned;

	public:
		body_type body_part:N_depth{};

	public:
	//	using S_::S_;
		using S_::self;

		XTAL_NEW_(delete) (subtype, noexcept = default)
		XTAL_NEW_(create) (subtype, noexcept = default)
		XTAL_NEW_(move)   (subtype, noexcept = default)
		XTAL_NEW_(copy)   (subtype, noexcept = default)
		XTAL_NEW_(cast)   (subtype, noexcept)
		
		///\
		Constructs `this` using the first argument, forwarding the rest to the parent. \

		XTAL_NEW_(explicit)
		subtype(integral_q auto &&a)
		noexcept
		:	S_(head_type(XTAL_REF_(a)) >> N_depth)
		,	body_part(head_type(a)&(N_width - 1))
		{
		}
		XTAL_NEW_(explicit)
		subtype(infungible_q<subtype> auto &&a, auto &&...oo)
		noexcept
		:	S_(XTAL_REF_(oo)...)
		,	body_part(member_f<head_type>(XTAL_REF_(a)))
		{
		}

		///\returns the kernel-body (prior to reconstruction using the given arguments, if provided). \

		XTAL_FX2_(to) (XTAL_DEF_(return,inline,get)
		head(), head_type{body_part})

		///\returns the underlying index. \
		
		///\todo\
		Determine whether this is aggregated? \

		XTAL_FX1_(to) (XTAL_DEF_(return,inline,explicit)
		operator size_type(), body_part)

	};
};
template <size_type N_depth>
struct defer_field<null_type[N_depth]>
:	defer_field<unit_type[(one << N_depth)]>
{
};


///////////////////////////////////////////////////////////////////////////////

template <class U>
struct refer_iterators
{
	template <class S>
	class subtype : public S
	{
	public:
		using S::S; static_assert(any_q<S>);

	};
	template <class S> requires iterable_q<U>
	class subtype<S> : public S
	{
	public:
		using S::S; static_assert(any_q<S>);

		XTAL_DEF_(return,inline,let) begin() const noexcept requires requires (U const &u) {_xtd::ranges::begin(u);} {return _xtd::ranges::begin(S::template head<U>());}
		XTAL_DEF_(return,inline,let) begin()       noexcept requires requires (U       &u) {_xtd::ranges::begin(u);} {return _xtd::ranges::begin(S::template head<U>());}
		XTAL_DEF_(return,inline,let)   end() const noexcept requires requires (U const &u) {_xtd::ranges::  end(u);} {return _xtd::ranges::  end(S::template head<U>());}
		XTAL_DEF_(return,inline,let)   end()       noexcept requires requires (U       &u) {_xtd::ranges::  end(u);} {return _xtd::ranges::  end(S::template head<U>());}

		XTAL_FX2_(do) (template <shaped_q X> requires un_n<counter_q<X>> and un_n<counted_q<X>>
		XTAL_DEF_(return,inline,let)
		subhead(X &&x),
		noexcept -> decltype(auto)
		{
			return subhead(XTAL_REF_(x).size());
		})
		XTAL_FX2_(do) (template <counter_q V>
		XTAL_DEF_(return,inline,let)
		subhead(V &&v),
		noexcept -> decltype(auto)
		{
			return subhead(counted_f(0, XTAL_REF_(v)));
		})
		XTAL_FX2_(do) (template <counted_q W>
		XTAL_DEF_(return,let)
		subhead(W &&w),
		noexcept -> decltype(auto)
		{
			using _xtd::ranges::next;
			using _xtd::ranges::views::slice;

			auto &u  = S::template head<U>();
			auto  u_ = begin();
			using W_ = reiterated_t<decltype(u_)>;
			auto  w0 = w.front(), wN = w.back() + 1;
			/*/
			size_type const uN = count_f(u);
			w0 = _std::min(w0, uN);
			wN = _std::min(wN, uN);
			/***/

			XTAL_IF0
			XTAL_0IF (interval_q<U>) {
				return typename S::head_type(u_[w0], u_[wN]);
			}
			XTAL_0IF (indexed_q<U>) {
				return W_(next(u_, w0), next(u_, wN));
			}
			XTAL_0IF_(else) {
				return u|slice(w0, wN);
			}
		})

	};
};


///////////////////////////////////////////////////////////////////////////////

template <class U>
struct refer_equality
{
	template <class S>
	class subtype : public S
	{
		static_assert(any_q<S>);
	public:
		using S::S;
		
		XTAL_DEF_(return,inline,let)
		operator == (subtype const &t) const
		noexcept -> bool
		requires requires (U const &u)
			{       equivalent_f(u        , t.head());}
			{return equivalent_f(S::head(), t.head());}

	};
};
template <class U>
struct refer_inequality
{
	template <class S>
	class subtype : public S
	{
	public:
		using S::S; static_assert(any_q<S>);
		
		XTAL_DEF_(return,inline,let)
		operator <=> (subtype const &t) const
		noexcept -> auto
		requires requires (U const &u)
			{       u         <=> t.head();}
			{return S::head() <=> t.head();}

	};
};

template <class U>
struct refer_qualities
:	bond::compose<void
	,	refer_equality<U>
	,	refer_inequality<U>
	>
{
};


////////////////////////////////////////////////////////////////////////////////

template <class U, int N=0>
struct refer_binary_logic
:	bond::compose<void
	,	refer_binary_logic<U, 1>
	,	refer_binary_logic<U, 2>
	>
{
};
template <class U>
struct refer_binary_logic<U, 1>
{
	template <class S>
	class subtype : public S
	{
	public:
		using S::S; static_assert(any_q<S>);
		XTAL_DEF_(mutate,inline,get) operator ^=(auto const &o) noexcept requires requires (U &u) {u ^= o;} {return bond::seek_front_f(S::self(), S::head() ^=o);}
		XTAL_DEF_(mutate,inline,get) operator |=(auto const &o) noexcept requires requires (U &u) {u |= o;} {return bond::seek_front_f(S::self(), S::head() |=o);}
		XTAL_DEF_(mutate,inline,get) operator &=(auto const &o) noexcept requires requires (U &u) {u &= o;} {return bond::seek_front_f(S::self(), S::head() &=o);}

	};
};
template <class U>
struct refer_binary_logic<U, 2>
{
	template <class S>
	class subtype : public S
	{
	public:
		using S::S; static_assert(any_q<S>);
		XTAL_DEF_(return,inline,get) operator ^ (auto const &o) const noexcept requires requires (U const &u) {u ^ o;} {return typename S::self_type( S::head() ^ o);}
		XTAL_DEF_(return,inline,get) operator | (auto const &o) const noexcept requires requires (U const &u) {u | o;} {return typename S::self_type( S::head() | o);}
		XTAL_DEF_(return,inline,get) operator & (auto const &o) const noexcept requires requires (U const &u) {u & o;} {return typename S::self_type( S::head() & o);}

	};
};

template <class U, int N=0>
struct refer_logics
:	bond::compose<void
	,	refer_binary_logic<U, N>
	>
{
};


////////////////////////////////////////////////////////////////////////////////

template <class U, int N=0>
struct refer_multiplicative_group
:	bond::compose<void
	,	refer_multiplicative_group<U, 1>
	,	refer_multiplicative_group<U, 2>
	>
{
};
template <class U>
struct refer_multiplicative_group<U, 1>
{
	template <class S>
	class subtype : public S
	{
	public:
		using S::S; static_assert(any_q<S>);
		XTAL_DEF_(mutate,inline,get) operator *=(auto const &o) noexcept requires requires (U &u) {u *= o;} {return bond::seek_front_f(S::self(), S::head() *=o);}
		XTAL_DEF_(mutate,inline,get) operator /=(auto const &o) noexcept requires requires (U &u) {u /= o;} {return bond::seek_front_f(S::self(), S::head() /=o);}

	};
};
template <class U>
struct refer_multiplicative_group<U, 2>
{
	template <class S>
	class subtype : public S
	{
	public:
		using S::S; static_assert(any_q<S>);
		XTAL_DEF_(return,inline,get) operator * (auto const &o) const noexcept requires requires (U const &u) {u * o;} {return typename S::self_type( S::head() * o);}
		XTAL_DEF_(return,inline,get) operator / (auto const &o) const noexcept requires requires (U const &u) {u / o;} {return typename S::self_type( S::head() / o);}

	};
};


template <class U, int N=0>
struct refer_additive_group
:	bond::compose<void
	,	refer_additive_group<U, 1>
	,	refer_additive_group<U, 2>
	>
{
};
template <class U>
struct refer_additive_group<U, 1>
{
	template <class S>
	class subtype : public S
	{
	public:
		using S::S; static_assert(any_q<S>);
		XTAL_DEF_(mutate,inline,get) operator +=(auto const &o) noexcept requires requires (U &u) {u += o;} {return bond::seek_front_f(S::self(), S::head() +=o);}
		XTAL_DEF_(mutate,inline,get) operator -=(auto const &o) noexcept requires requires (U &u) {u -= o;} {return bond::seek_front_f(S::self(), S::head() -=o);}

	};
};
template <class U>
struct refer_additive_group<U, 2>
{
	template <class S>
	class subtype : public S
	{
	public:
		using S::S; static_assert(any_q<S>);
		XTAL_DEF_(return,inline,get) operator + (auto const &o) const noexcept requires requires (U const &u) { u + o;} {return typename S::self_type( S::head() + o);}
		XTAL_DEF_(return,inline,get) operator - (auto const &o) const noexcept requires requires (U const &u) { u - o;} {return typename S::self_type( S::head() - o);}
		XTAL_DEF_(return,inline,get) operator - (             ) const noexcept requires requires (U const &u) {-u    ;} {return typename S::self_type(-S::head());}

	};
};


template <class U, int N=0>
struct refer_discrete_group
:	bond::compose<void
	,	refer_discrete_group<U, 1>
	,	refer_discrete_group<U, 2>
	>
{
};
template <class U>
struct refer_discrete_group<U, 1>
{
	template <class S>
	class subtype : public S
	{
	public:
		using S::S; static_assert(any_q<S>);
		XTAL_DEF_(mutate,inline,get) operator ++(int) noexcept requires requires (U &u) {u++;} {return bond::seek_front_f(S::twin(), ++S::head());}
		XTAL_DEF_(mutate,inline,get) operator --(int) noexcept requires requires (U &u) {u++;} {return bond::seek_front_f(S::twin(), --S::head());}
		XTAL_DEF_(mutate,inline,get) operator ++(   ) noexcept requires requires (U &u) {++u;} {return bond::seek_front_f(S::self(), ++S::head());}
		XTAL_DEF_(mutate,inline,get) operator --(   ) noexcept requires requires (U &u) {++u;} {return bond::seek_front_f(S::self(), --S::head());}

	};
};
template <class U>
struct refer_discrete_group<U, 2>
{
	template <class S>
	using subtype = S;

};


template <class U, int N=0>
struct refer_groups
:	bond::compose<void
	,	refer_multiplicative_group<U, N>
	,	refer_additive_group<U, N>
	,	refer_discrete_group<U, N>
	>
{
};


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
