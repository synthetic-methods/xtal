








namespace _detail
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

using namespace _retail::_detail;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///\
Constructs/references the current value. \

template <class   ...Us>	XTAL_ASK         member_q = rebased_q<Us...>;
template <class      W >	XTAL_TYP         member            {using type = debased_t<W>;};
template <size_t     N >	XTAL_TYP         member<unit_t[N]> {using type =     unsigned;};
template <size_t     N >	XTAL_TYP         member<null_t[N]> {using type =     unsigned;};
template <class      W >	XTAL_USE         member_t = typename member<W>::type;
template <debased_q  W >	XTAL_DEF_(return,inline,static) XTAL_REF    member_f(auto &&   w)       XTAL_0EX {return & XTAL_REF_(w)    ;}
template <class      W >	XTAL_DEF_(return,inline,static) XTAL_REF    member_f(auto &&...w)       XTAL_0EX {return W(XTAL_REF_(w)...);}

///\
Resolves/dereferences the current value. \


template <class      W >	XTAL_TYP     remember            {using type =      W;};
template <size_t     N >	XTAL_TYP     remember<unit_t[N]> {using type = size_t;};
template <size_t     N >	XTAL_TYP     remember<null_t[N]> {using type = size_t;};
template <class      W >	XTAL_USE     remember_t = typename remember<W>::type;
template <pointer_q  M >	XTAL_DEF_(return,inline,static) XTAL_REF  remember_f(M &&m)             XTAL_0EX {return *XTAL_REF_(m);}
template <class      M >	XTAL_DEF_(return,inline,static) XTAL_REF  remember_f(M &&m)             XTAL_0EX {return  XTAL_REF_(m);}

///\
Replaces and returns the previous value. \

template <rebased_q  W >	XTAL_DEF_(return,inline,static) XTAL_REF dismember_f(W &m, W w)         XTAL_0EX {return _std::exchange(m, XTAL_MOV_(w));}
template <rebased_q  W >	XTAL_DEF_(return,inline,static) XTAL_REF dismember_f(W &m, auto &&...w) XTAL_0EX {return dismember_f<W>(m, member_f<W>(XTAL_REF_(w)...));}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

template <class T>
struct define_super
{
	using subkind = _retail::define<T>;

	template <class S>
	class subtype : public bond::compose_s<S, subkind>
	{
		using S_ = bond::compose_s<S, subkind>;
	
	public:
		using S_::S_;

	public:
		template <class ...Is>
		struct super : bond::seek_back<Is...> {};

	};
};


///////////////////////////////////////////////////////////////////////////////

template <class T>
struct refine_head
{
	template <any_q S>
	class subtype : public S
	{
		using S_ = S;

	public:
		using S_::S_;

	};
	template <any_q S> requires (1 == S::pack_size::value)
	class subtype<S> : public S
	{
		using S_ = S;

	protected:
		using typename S_::T_self;
		using typename S_::U_head;

	public:
		using S_::S_;
		using S_::twin;
		using S_::self;
		using S_::head;

		///\
		Implicit conversion to the singleton kernel-type. \

		XTAL_DO4_(XTAL_CVN_(implicit) U_head(), {return head();})
		
//		///\
//		\returns a copy of `this` with `head<Is...>(oo...)` applied. \
//
//		template <class  ...Is>
//		XTAL_REF alter(auto &&...oo)
//		XTAL_0FX
//		{
//			auto t = twin();
//			(void) t.template head<Is...>(XTAL_REF_(oo)...);
//			return t;
//		}

	};
};
template <class T>
struct refine_tuple
{
	template <any_q S>
	class subtype : public S
	{
		using S_ = S;

	public:
		using S_::S_;
		using typename S_::pack_size;

		///\
		Tuple application. \

		XTAL_DO2_(XTAL_DEF_(inline)
		XTAL_REF apply(auto &&f),
		{
			if constexpr (not pack_size::value) {
				return XTAL_REF_(f) ();
			}
			else {
				return [this, f = XTAL_REF_(f)] <size_t ...I>(bond::seek_t<I...>)
					XTAL_0FN_(f(S_::template head<I>()...))
				(bond::seek_s<pack_size::value> {});
			}
		})
		template <class F>
		XTAL_DEF_(return,inline)
		XTAL_REF apply()
		XTAL_0EX
		{
			return apply(invoke_f<F>);
		}

		///\
		Sequence conversion. \

		XTAL_DEF_(return,inline)
		XTAL_LET seek()
		XTAL_0FX
		{
			return apply(bond::seek_f);
		}
		///\
		Tuple conversion. \

		XTAL_DEF_(return,inline)
		XTAL_LET pack()
		XTAL_0FX
		{
			return apply(bond::pack_f);
		}
		XTAL_DEF_(return,inline,static)
		XTAL_LET pack_f(bond::pack_q auto const &tuple)
		XTAL_0EX
		{
			return _std::apply([] XTAL_1FN_(T), tuple);
		}

		XTAL_TO4_(XTAL_CVN_(implicit) bond::pack_row_t<S_>(), pack())

	};
};


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

template <class U>
struct defer_field
{
	template <any_q S>
	class subtype : public bond::compose_s<S>
	{
		using S_ = bond::compose_s<S>;

	protected:
		using typename S_::T_self;
		using U_head = remember_t<U>;
		using U_body =   member_t<U>;

	public:
		//\
		Public visibility allows `auto` parameterization in templates.

		U_body u_body;

	public:
	//	using S_::S_;
		
		XTAL_CO0_(subtype)
	//	XTAL_CO1_(subtype)
		XTAL_CO4_(subtype)
		
		template <fungible_q<subtype> O>
		XTAL_CON_(explicit) subtype(O &&o)
		XTAL_0EX
		:	subtype(static_cast<subtype &&>(XTAL_REF_(o)))
		{}
		template <bond::selfish_tab_q<U> O>
		XTAL_CON_(explicit) subtype(O &&o, auto &&...oo)
		XTAL_0EX
		:	subtype(XTAL_REF_(o).apply([] XTAL_1FN_(U)), XTAL_REF_(oo)...)
		{}

		///\
		Constructs `this` using the default value. \

		XTAL_CON_(implicit) subtype()
		XTAL_0EX
		:	subtype(U_body{})
		{}
		XTAL_CON_(implicit) subtype(reembrace_t<U_body> o)
		XTAL_0EX
		XTAL_REQ member_q<U> and reembrace_q<U_body>
		:	u_body(o)
		{}
		///\
		Constructs `this` using the first argument, forwarding the rest to the parent. \

		XTAL_CON_(explicit) subtype(auto &&o, auto &&...oo)
		XTAL_0EX
		:	S_(XTAL_REF_(oo)...)
		,	u_body(member_f<U_head>(XTAL_REF_(o)))
		{}

		///\returns the kernel-body (prior to reconstruction using the given arguments, if provided). \

		XTAL_DEF_(return,inline) XTAL_REF head() XTAL_0FX_( &) {return remember_f(u_body);}
		XTAL_DEF_(return,inline) XTAL_REF head() XTAL_0EX_( &) {return remember_f(u_body);}
		XTAL_DEF_(return,inline) XTAL_REF head() XTAL_0FX_(&&) {return remember_f(XTAL_MOV_(u_body));}
		XTAL_DEF_(return,inline) XTAL_REF head() XTAL_0EX_(&&) {return remember_f(XTAL_MOV_(u_body));}
		
		XTAL_DEF_(inline)
		XTAL_REF head(auto &&...oo)
		XTAL_0EX
		XTAL_REQ member_q<U_head> and (0 < sizeof...(oo))
		{
			return dismember_f(u_body, XTAL_REF_(oo)...);
		}

	};
};
template <Integral_q U>
struct defer_field<U>
{
	template <any_q S>
	class subtype : public bond::compose_s<S>
	{
		using S_ = bond::compose_s<S>;

	protected:
		using typename S_::T_self;
		using U_head = remember_t<U>;
		using U_body =   member_t<U>;

	public:
		using S_::S_;
		using S_::self;
		U_body u_body{};

		template <Integral_q A>
		XTAL_CON_(explicit) subtype(A &&a, auto &&...oo)
		XTAL_0EX
		:	S_(XTAL_REF_(oo)...)
		{
			static_assert(A::value == U::value);
		}

		///\returns the kernel-body (prior to reconstruction using the given arguments, if provided). \

		XTAL_DEF_(return,inline) XTAL_REF head() XTAL_0FX {return U_head(u_body);}
		XTAL_DEF_(return,inline) XTAL_REF head() XTAL_0EX {return U_head(u_body);}
		
	};
};
template <size_t N_width>
struct defer_field<unit_t[N_width]>
{
	using U = unit_t[N_width];

	static constexpr size_t N_depth = bond::operating::bit_ceiling_f(N_width);
	static_assert(N_width == size_1 << N_depth);

	using subkind = bond::assay<N_width>;

	template <any_q S>
	class subtype : public bond::compose_s<S, subkind>
	{
		using S_ = bond::compose_s<S, subkind>;

	protected:
		using typename S_::T_self;
		using U_head = remember_t<U>;
		using U_body =   member_t<U>;

	public:
		U_body u_body:N_depth{};

	public:
	//	using S_::S_;
		using S_::self;

		XTAL_CO0_(subtype);
		XTAL_CO1_(subtype);
		XTAL_CO4_(subtype);
		
		template <fungible_q<subtype> O>
		XTAL_CON_(explicit) subtype(O &&o)
		XTAL_0EX
		:	subtype(static_cast<subtype &&>(XTAL_REF_(o)))
		{}
		///\
		Constructs `this` using the first argument, forwarding the rest to the parent. \

		template <integral_q A>
		XTAL_CON_(explicit) subtype(A &&a)
		XTAL_0EX
		:	S_(U_head(XTAL_REF_(a)) >> N_depth)
		,	u_body(U_head(a)&(N_width - 1))
		{
		}
		template <infungible_q<subtype> A>
		XTAL_CON_(explicit) subtype(A &&a, auto &&...oo)
		XTAL_0EX
		:	S_(XTAL_REF_(oo)...)
		,	u_body(member_f<U_head>(XTAL_REF_(a)))
		{
		}

		///\returns the kernel-body (prior to reconstruction using the given arguments, if provided). \

		XTAL_DEF_(return,inline) XTAL_REF head() XTAL_0FX {return U_head(u_body);}
		XTAL_DEF_(return,inline) XTAL_REF head() XTAL_0EX {return U_head(u_body);}
		
	};
};
template <size_t N_depth>
struct defer_field<null_t[N_depth]>
:	defer_field<unit_t[(size_1 << N_depth)]>
{
};


///////////////////////////////////////////////////////////////////////////////

template <class U>
struct refer_iterators
{
	template <any_q S>
	class subtype : public S
	{
		using S_ = S;
		using U_ = _std::remove_reference_t<U>;

	public:
		using S_::S_;

		XTAL_DEF_(return,inline) XTAL_REF begin() XTAL_0FX requires requires (U_ const &u_) {_xtd::ranges::begin(u_);} {return _xtd::ranges::begin(S_::template head<U>());}
		XTAL_DEF_(return,inline) XTAL_REF begin() XTAL_0EX requires requires (U_       &u_) {_xtd::ranges::begin(u_);} {return _xtd::ranges::begin(S_::template head<U>());}
		XTAL_DEF_(return,inline) XTAL_REF   end() XTAL_0FX requires requires (U_ const &u_) {_xtd::ranges::  end(u_);} {return _xtd::ranges::  end(S_::template head<U>());}
		XTAL_DEF_(return,inline) XTAL_REF   end() XTAL_0EX requires requires (U_       &u_) {_xtd::ranges::  end(u_);} {return _xtd::ranges::  end(S_::template head<U>());}

		XTAL_DO2_(template <counted_q V>
		XTAL_DEF_(return,inline)
		XTAL_REF subhead(V &&v),
		{
			using _xtd::ranges::next;
			using _xtd::ranges::views::slice;

			auto &u  = S_::template head<U>();
			auto  u_ = begin();
			using W_ = reiterated_t<decltype(u_)>;
			auto  v0 = v.front(), vN = v.back() + 1;
			/*/
			size_t const uN = count_f(u);
			v0 = _std::min(v0, uN);
			vN = _std::min(vN, uN);
			/***/

			XTAL_IF0
			XTAL_0IF (interval_q<U>) {
				return U_(u_[v0], u_[vN]);
			}
			XTAL_0IF (accessed_q<U>) {
				return W_(next(u_, v0), next(u_, vN));
			}
			XTAL_0IF_(default) {
				return u|slice(v0, vN);
			}
		})

	};
};

template <class U>
struct infer_iterators : bond::compose<> {};

template <class U> requires iterable_q<U>
struct infer_iterators<U> : refer_iterators<U> {};


///////////////////////////////////////////////////////////////////////////////

template <class U>
struct refer_equality
{
	template <any_q S>
	class subtype : public S
	{
	public:
		using S::S;
		XTAL_DEF_(return,inline) XTAL_LET operator == (subtype const &t) XTAL_0FX -> bool {return S::head() == t.head();}
		XTAL_DEF_(return,inline) XTAL_LET operator != (subtype const &t) XTAL_0FX -> bool {return S::head() != t.head();}

	};
};

template <class U>
struct infer_equality : bond::compose<> {};

template <class U> requires equality_q<U>
struct infer_equality<U> : refer_equality<U> {};


template <class U>
struct refer_inequality
{
	template <any_q S>
	class subtype : public S
	{
		using S_ = S;

	public:
		using S_::S_;
		
		XTAL_DEF_(return,inline)
		XTAL_REF operator <=> (subtype const &t)
		XTAL_0FX
		{
			return S_::head() <=> t.head();
		}

	};
};

template <class U>
struct infer_inequality : bond::compose<> {};

template <class U> requires inequality_q<U>
struct infer_inequality<U> : refer_inequality<U> {};


template <class U>
struct refer_qualities
:	bond::compose<void
	,	refer_equality<U>
	,	refer_inequality<U>
	>
{};
template <class U>
struct infer_qualities
:	bond::compose<void
	,	infer_equality<U>
	,	infer_inequality<U>
	>
{};


////////////////////////////////////////////////////////////////////////////////

template <class U, size_t N=0>
struct refer_binary_logic
:	bond::compose<void
	,	refer_binary_logic<U, 1>
	,	refer_binary_logic<U, 2>
	>
{};
template <class U>
struct refer_binary_logic<U, 1>
{
	template <any_q S>
	class subtype : public S
	{
		using S_ = S;

	public:
		using S_::S_;
		XTAL_DEF_(inline) XTAL_REF operator ^=(auto &&o) XTAL_0EX {S_::head() ^= XTAL_REF_(o); return S_::self();}
		XTAL_DEF_(inline) XTAL_REF operator |=(auto &&o) XTAL_0EX {S_::head() |= XTAL_REF_(o); return S_::self();}
		XTAL_DEF_(inline) XTAL_REF operator &=(auto &&o) XTAL_0EX {S_::head() &= XTAL_REF_(o); return S_::self();}

	};
};
template <class U>
struct refer_binary_logic<U, 2>
{
	template <any_q S>
	class subtype : public S
	{
		using S_ = S;

	protected:
		using typename S_::T_self;
	
	public:
		using S_::S_;
		XTAL_DEF_(return,inline) XTAL_LET operator ^ (auto &&o) XTAL_0FX -> T_self {return T_self(S_::head() ^ XTAL_REF_(o));}
		XTAL_DEF_(return,inline) XTAL_LET operator | (auto &&o) XTAL_0FX -> T_self {return T_self(S_::head() | XTAL_REF_(o));}
		XTAL_DEF_(return,inline) XTAL_LET operator & (auto &&o) XTAL_0FX -> T_self {return T_self(S_::head() & XTAL_REF_(o));}

	};
};

template <class U, size_t N=0>
struct infer_binary_logic : bond::compose<> {};

template <class U, size_t N> requires binary_lattice_p<N, U>
struct infer_binary_logic<U, N> : refer_binary_logic<U, N> {};



template <class U, size_t N=0>
struct refer_logics
:	bond::compose<void
	,	refer_binary_logic<U, N>
	>
{};
template <class U, size_t N=0>
struct infer_logics
:	bond::compose<void
	,	infer_binary_logic<U, N>
	>
{};


////////////////////////////////////////////////////////////////////////////////

template <class U, size_t N=0>
struct refer_multiplicative_group
:	bond::compose<void
	,	refer_multiplicative_group<U, 1>
	,	refer_multiplicative_group<U, 2>
	>
{};
template <class U>
struct refer_multiplicative_group<U, 1>
{
	template <any_q S>
	class subtype : public S
	{
	public:
		using S::S;
		XTAL_DEF_(inline) XTAL_REF operator *=(auto &&o) XTAL_0EX {S::head() *= XTAL_REF_(o); return S::self();}
		XTAL_DEF_(inline) XTAL_REF operator /=(auto &&o) XTAL_0EX {S::head() /= XTAL_REF_(o); return S::self();}

	};
};
template <class U>
struct refer_multiplicative_group<U, 2>
{
	template <any_q S>
	class subtype : public S
	{
		using S_ = S;

	protected:
		using typename S_::T_self;
	
	public:
		using S_::S_;
		XTAL_DEF_(return,inline) XTAL_LET operator * (auto &&o) XTAL_0FX -> T_self {return T_self(S_::head() * XTAL_REF_(o));}
		XTAL_DEF_(return,inline) XTAL_LET operator / (auto &&o) XTAL_0FX -> T_self {return T_self(S_::head() / XTAL_REF_(o));}

	};
};

template <class U, size_t N=0>
struct infer_multiplicative_group : bond::compose<> {};

template <class U, size_t N> requires multiplicative_group_p<N, U>
struct infer_multiplicative_group<U, N> : refer_multiplicative_group<U, N> {};



template <class U, size_t N=0>
struct refer_additive_group
:	bond::compose<void
	,	refer_additive_group<U, 1>
	,	refer_additive_group<U, 2>
	>
{};
template <class U>
struct refer_additive_group<U, 1>
{
	template <any_q S>
	class subtype : public S
	{
	public:
		using S::S;
		XTAL_DEF_(inline) XTAL_REF operator +=(auto &&o) XTAL_0EX {S::head() += XTAL_REF_(o); return S::self();}
		XTAL_DEF_(inline) XTAL_REF operator -=(auto &&o) XTAL_0EX {S::head() -= XTAL_REF_(o); return S::self();}

	};
};
template <class U>
struct refer_additive_group<U, 2>
{
	template <any_q S>
	class subtype : public S
	{
		using S_ = S;

	protected:
		using typename S_::T_self;
	
	public:
		using S_::S_;
		XTAL_DEF_(return,inline) XTAL_LET operator + (auto &&o) XTAL_0FX -> T_self {return T_self( S_::head() + XTAL_REF_(o));}
		XTAL_DEF_(return,inline) XTAL_LET operator - (auto &&o) XTAL_0FX -> T_self {return T_self( S_::head() - XTAL_REF_(o));}
		XTAL_DEF_(return,inline) XTAL_LET operator - (        ) XTAL_0FX -> T_self {return T_self(-S_::head());}

	};
};

template <class U, size_t N=0>
struct infer_additive_group : bond::compose<> {};

template <class U, size_t N> requires additive_group_p<N, U>
struct infer_additive_group<U, N> : refer_additive_group<U, N> {};



template <class U, size_t N=0>
struct refer_discrete_group
:	bond::compose<void
	,	refer_discrete_group<U, 1>
	,	refer_discrete_group<U, 2>
	>
{};
template <class U>
struct refer_discrete_group<U, 1>
{
	template <any_q S>
	class subtype : public S
	{
	public:
		using S::S;
		XTAL_DEF_(inline) XTAL_REF operator ++(int) XTAL_0EX {auto  t = S::self(); ++S::head(); return t;}
		XTAL_DEF_(inline) XTAL_REF operator --(int) XTAL_0EX {auto  t = S::self(); --S::head(); return t;}
		XTAL_DEF_(inline) XTAL_REF operator ++()    XTAL_0EX {auto &s = S::self(); ++S::head(); return s;}
		XTAL_DEF_(inline) XTAL_REF operator --()    XTAL_0EX {auto &s = S::self(); --S::head(); return s;}

	};
};
template <class U>
struct refer_discrete_group<U, 2>
{
	template <any_q S>
	using subtype = S;

};

template <class U, size_t N=0>
struct infer_discrete_group : bond::compose<> {};

template <class U, size_t N> requires discrete_group_p<N, U>
struct infer_discrete_group<U, N> : refer_discrete_group<U, N> {};



template <class U, size_t N=0>
struct refer_groups
:	bond::compose<void
	,	refer_multiplicative_group<U, N>
	,	refer_additive_group<U, N>
	,	refer_discrete_group<U, N>
	>
{};
template <class U, size_t N=0>
struct infer_groups
:	bond::compose<void
	,	infer_multiplicative_group<U, N>
	,	infer_additive_group<U, N>
	,	infer_discrete_group<U, N>
	>
{};


}//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
