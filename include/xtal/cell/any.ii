//////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
//\
This naked header is intended for inclusion within a `namespace` providing the decorators: \

template <class U> XTAL_TYP defer;///<   Proxies `U`.
template <class U> XTAL_TYP refer;///< Delegates `U`.

template <class T> XTAL_TYP define;///< Initializes `T`.
template <class T> XTAL_TYP refine;///<   Finalizes `T`.


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///\
Associates the internal `subtype` both with the current namespace, \
the parent namespace, and with the decorators `As...` if provided. \

template <            typename ...As> XTAL_TYP any   : bond::compose<_retail::any<As...>, bond::tag<any>> {};
template <class    S, typename ...As> XTAL_USE any_s = bond::compose_s<     S, any<As...>>;
template <            typename ...As> XTAL_USE any_t = bond::compose_s<unit_t, any<As...>>;
template <class    T, typename ...As> XTAL_ASK any_p = bond::head_tag_p<any, T> and complete_q<typename T::template self_s<As...>>;
template <class ...Ts               > XTAL_ASK any_q = bond::head_tag_p<any, Ts...>;

template <size_t N> XTAL_FN1 get(any_q auto const &&t) XTAL_0EX {return XTAL_MOV_(t).template head<N>();};
template <size_t N> XTAL_FN1 get(any_q auto       &&t) XTAL_0EX {return XTAL_MOV_(t).template head<N>();};
template <size_t N> XTAL_FN1 get(any_q auto const  &t) XTAL_0EX {return          (t).template head<N>();};
template <size_t N> XTAL_FN1 get(any_q auto        &t) XTAL_0EX {return          (t).template head<N>();};


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///\
Combines `define` and `refine` to materialize the curiously recursive type `T`, \
sandwiching the decorators `As...`. \

template <class T, typename ...As>
struct confine
{
	using subkind = bond::compose<refine<T>, As..., define<T>>;

	template <class S>
	using subtype = bond::compose_s<S, subkind>;
	using    type = T;
	
};
template <class T, typename ...As>
using confine_t = typename confine<T, As...>::template subtype<any_t<>>;

///\
Creates the `confine`d _decorator_ with `As...`. \

template <typename ...As>
struct confined
{
	template <class T>
	using homokind = bond::compose<refine<T>, As..., define<T>>;

	template <class S>
	using subtype = bond::compose_s<S, bond::isokind<homokind>>;
	using    type = subtype<any_t<>>;
	
};
template <typename ...As>
using confined_t = typename confined<As...>::type;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///\
Combines `defer` and `refer` to lift `U`, sandwiching the decorators `As...`. \

template <class U, typename ...As> XTAL_TYP confer      : bond::compose<refer<U>, As..., defer<U>> {};
template <class U, typename ...As> XTAL_USE conferred   = confined<confer<U, As...>>;
template <class U, typename ...As> XTAL_USE conferred_t = typename conferred<U, As...>::type;


////////////////////////////////////////////////////////////////////////////////
///\
Applies `refer` to the outermost `head_t` iff `1 == arity()`. \

struct referree
{
	struct subkind
	{
		template <any_q S>
		using subtype = bond::compose_s<S, refer<typename S::template head_t<>>>;

	};
	template <any_q S>
	class subtype : public S
	{
		using S_ = S;
	
	public:
		using S_::S_;

	};
	template <any_q S> requires (1 == _std::tuple_size<S> {})
	class subtype<S> : public bond::compose_s<S, subkind>
	{
		using S_ = bond::compose_s<S, subkind>;
	
	public:
		using S_::S_;

	};
	
};
///\
Unless `A` is already a decorator, \
provides `defer<A>` or `any<A>` depending on whether `complete_q<A>`. \

template <class           A          >	struct infer       :             defer<A>                    {};
template <bond::compose_q A          >	struct infer<A   > :                   A                     {};
template <incomplete_q    A          >	struct infer<A   > :               any<A>                    {};
template <incomplete_q    A, size_t N>	struct infer<A[N]> : bond::compose<any<A>, defer<unit_t[N]>> {};
template <                           >	struct infer<void> : bond::compose<                        > {};

template <class   ...As>	XTAL_USE infers     = bond::compose<infer<As>...>; 
template <class   ...As>	XTAL_USE inferred   = confined<referree, infers<As...>>;
template <class   ...As>	XTAL_USE inferred_t = typename inferred<As...>::type;
///<\
Creates a `confined` `infers<As...>`, delegating to the outermost `complete_q<head_t<>>`. \



////////////////////////////////////////////////////////////////////////////////
///\
Creates a unique tuple `inferred` from `...As`. \

template <class   ...Ts>	XTAL_TYP packed     : inferred<Ts..., bond::tag<packed>> {};
template <class   ...Ts>	XTAL_USE packed_t   = typename packed<Ts...>::type;
template <class   ...Ts>	XTAL_ASK packed_q   = any_p<class packed_a, Ts...>;
template <class   ...Ts>	XTAL_TN2 packed_f(Ts &&...as) XTAL_0EX {return packed<Ts...>(XTAL_REF_(as)...);}

///\
Defines `type` by `T` if `any_q<T>`, otherwise `conferred_t<T>`. \

template <class      T >	XTAL_TYP let          {using type = conferred_t<T>;};
template <any_q      T >	XTAL_TYP let<T>       {using type =             T ;};
template <class      T >	XTAL_USE let_t      = typename let<T>::type;
template <class      T >	XTAL_TN2 let_f(T &&t) XTAL_0EX {return conferred_t<T>(XTAL_REF_(t));}
template <any_q      T >	XTAL_TN2 let_f(T &&t) XTAL_0EX {return               (XTAL_REF_(t));}
///<\
\returns `w` if `any_q<decltype(w)>`, otherwise proxies `w` using `conferred_t`. \


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
