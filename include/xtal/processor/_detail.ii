namespace _detail
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

using namespace _retail::_detail;


////////////////////////////////////////////////////////////////////////////////

template <class   ...Ts>	concept unprocessed_q = not _retail::any_q<Ts...> and contiguous_field_q<Ts...>;
template <class   ...Ts>	concept reprocessed_q =     _retail::any_q<Ts...> and not iterated_q<Ts...>;


////////////////////////////////////////////////////////////////////////////////

template <class T, class Y=T>
concept connection_p = any_q<T> and requires (T t)
{
	{t.state()} -> isomorphic_q<Y>;
};
template <class T, class Y=T>
concept collection_p = any_q<T> and requires (T t)
{
	{t.state()} -> isomorphic_q<Y>;
	{t.store()} -> isomorphic_q<Y>;
};
template <class T, class Y>
concept recollection_p = collection_p<T, Y> and _std::is_rvalue_reference_v<T>;


}//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
