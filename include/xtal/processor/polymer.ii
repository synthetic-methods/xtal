#pragma once
#include "./any.ii"
#include "./monomer.ii"
#include "../resource/all.ii"
#include "../compound/key.ii"
#include "../message/stage.ii"


XTAL_ENV_(push)
namespace xtal::processor
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <typename ..._s> XTAL_NYM polymer;
template <typename ..._s> XTAL_ASK polymer_q = common::tag_p<polymer, _s...>;
template <typename ..._s> XTAL_USE polymer_t = confined_t<polymer< _s...>>;
template <typename ...As>
XTAL_FN2  polymer_f(XTAL_DEF  u)
XTAL_0EZ_(polymer_t<XTAL_TYP_(u), As...>(XTAL_REF_(u)))


////////////////////////////////////////////////////////////////////////////////
///\
Polyphonic voice allocator. Functionally similar to `monomer`, \
but expands/contracts the voice store according to `message::stage` requests/responses. \

///\note\
The attached `restore` and `respool` determine the sample buffer and voice spool respectively. \

template <class U, typename ...As>
struct polymer<U, As...>
{
	using subkind = monomer<U, As...>;

	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		using _S = common::compose_s<S, subkind>;
		using _I = monomer_t<based_t<U>>;
		
		template <class ...Xs>
		using _F = typename _S::template bond<Xs...>;

	public:
		using _S::_S;
		using _S::self;

		template <class ...Xs> requires resource::respool_q<_S> and resource::restore_q<_S>
		struct bond: _F<Xs...>
		{
			using rebound = _F<Xs...>;
			
			using return_t = typename rebound::return_t;

			using event_t = message::stage_t<>;
			using event_u = compound::key_s<event_t>;
			
			using voice_t = typename _I::template bond_t<Xs...>;
			using voice_u = compound::key_s<voice_t>;
			
			using ensemble_u = typename _S::template spool_t<voice_u>;

			using subkind = common::compose<common::tag<polymer>
			,	defer<voice_t>
			,	As...// NOTE: Necessary for `intermit`...
			,	rebound
			>;
			template <any_q R>
			class subtype: public common::compose_s<R, subkind>
			{
				using _R = common::compose_s<R, subkind>;
				
				ensemble_u m_ensemble;

			public:
				using _R::_R;
				using _R::self;
				using _R::head;
				using _R::serve;
				using _R::store;
				
				XTAL_TO2_(XTAL_TN2 ensemble(), m_ensemble)

				using _R::influx;
				
				///\
				Forwards the `compound::key`ed message to the associated instance. \
				Messages associated with a `message/stage.ii` designate events, \
				and govern the allocation/deallocation of keyed instances. \
				
				///\note\
				If an incoming event is active `(0)`, \
				the top-most associated instance is cut `(-1)` \
				before a new instance is allocated from the prototype `head`. \

				XTAL_TLX influx(compound::key_q auto io, XTAL_DEF ...oo)
				XTAL_0EX
				{
					auto const i = io.head();
					auto const o = io.core();
					return influx(compound::key_s<>(i), o, XTAL_REF_(oo)...);
				}
				XTAL_TLX influx(compound::key_s<> i, XTAL_DEF ...oo)
				XTAL_0EX
				{
					auto h = i.head();
					auto w = m_ensemble.scan(h);
					assert(m_ensemble and h == w->head());
					return w->influx(XTAL_REF_(oo)...);
				}
				XTAL_TLX influx(compound::key_s<> i, event_t o, XTAL_DEF ...oo)
				XTAL_0EX
				{
					auto h = i.head();
					auto w = m_ensemble.scan(h);
				//	Detect and allocate incoming note-on, terminating if it already exists:
					if (0 == o) {
						if (m_ensemble and h == w->head()) {
							(void) w->influx(message::stage_f(-1), oo...);
						}
						w = m_ensemble.poke(w, h, head());
					}
				//	Forward to detected/allocated instance:
					assert(w->head() == h);
					return w->influx(o, XTAL_REF_(oo)...);
				}

				///\
				Forwards to all instances including the sentinel. \

				XTAL_TLX influx_push(XTAL_DEF ...oo)
				XTAL_0EX
				{
					bool constexpr impure = false;
					return _v3::ranges::accumulate(m_ensemble
					,	impure? -1: head().influx(oo...)
					,	[=] (XTAL_FLX flx, XTAL_DEF v)
							XTAL_0FN_(flx & XTAL_REF_(v).influx(oo...))
					);
				}
				XTAL_TLX efflux_pull(XTAL_DEF ...oo)
				XTAL_0EX
				{
					bool constexpr impure = (...or message::scope_q<decltype(oo)>);
					return _v3::ranges::accumulate(m_ensemble
					,	impure? -1: head().efflux(oo...)
					,	[=] (XTAL_FLX flx, XTAL_DEF v)
							XTAL_0FN_(flx & XTAL_REF_(v).efflux(oo...))
					);
				}

				///\
				Renders the buffer slice designated by `respan_x` and `scope_x`. \
				
				template <message::respan_q R_x, message::scope_q S_x>
				XTAL_TLX efflux_pull_slice(R_x respan_x, S_x scope_x, XTAL_DEF ...oo)
				XTAL_0EX
				{
					XTAL_FLX flx = -1;
				//	Render each instance, while releasing any that have terminated:
					for (auto _e = m_ensemble.end(); m_ensemble.begin() <= --_e;) {
						if (_e->efflux(message::stage_f(-1)) == 1) {
							m_ensemble.pop(_e);
						}
						else {
							flx &= _e->efflux(scope_x, oo...);
						}
					}
					if (1 == flx) return flx;// else...
				//	Initialize buffer with first instance, then progressively chunk/mix the rest:
					using namespace _v3;
					using namespace _detail;
					auto i = m_ensemble.begin(), iN = m_ensemble.end();
					tunnel_f(respan_x, i++);
					common::seek_n<-4>([&, this] (auto M)// 3, 2, 1, 0
					XTAL_0FN {
						size_t constexpr N = (size_t) 1 << M;// 8, 4, 2, 1
						for (; N <= _std::distance(i, iN); i += N) {
							tunnel_f<N>(respan_x, i);
						}
					});
					return flx;
				}
				
			};
		};

	};
};

///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
