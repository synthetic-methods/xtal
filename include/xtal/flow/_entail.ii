#include "../cell/_entail.ii"








//line namespace _entail
//////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
///\
Defines an `inferred` tuple from `...As`. \

//\
template <class ...Ts>	struct    packed   : inferred<bond::tag<packed>, Ts...> {};
template <class ...Ts>	struct    packed;
template <class ...Ts>	using     packed_t = typename packed<Ts...>::type;
template <class ...Ts>	concept   packed_q =     bond::tag_p<packed, Ts...>;
template <class ...Ts>	concept unpacked_q = not bond::tag_p<packed, Ts...>;

auto constexpr packed_f = []<class ...Ts> (Ts &&...ts)
XTAL_0FN_(to) (packed_t<Ts...>(static_cast<Ts &&> (ts)...));

template <class ...Ts>
struct   packed
{
	using superkind = inferred<bond::tag<packed>, Ts...>;

	template <class S>
	class subtype : public bond::compose_s<S, superkind>
	{
		using S_ = bond::compose_s<S, superkind>;

	public:// CONSTRUCT
		using S_::S_;

		XTAL_DEF_(return,inline,let)
		operator, (unpacked_q auto &&t) const
		noexcept -> auto
		{
			return (S_::self(), packed_f(XTAL_REF_(t)));
		}
		XTAL_DEF_(return,inline,met)
		operator, (unpacked_q auto &&s, subtype       &&t)
		noexcept -> auto
		{
			return (packed_f(XTAL_REF_(s)), XTAL_MOV_(t).self());
		}
		XTAL_DEF_(return,inline,met)
		operator, (unpacked_q auto &&s, subtype const  &t)
		noexcept -> auto
		{
			return (packed_f(XTAL_REF_(s)), XTAL_REF_(t).self());
		}

		XTAL_DEF_(return,inline,met)
		operator, (subtype       &&s, packed_q auto &&t)
		noexcept -> auto
		{
			return bond::repack_f<packed_t>(XTAL_MOV_(s).self().pack(), XTAL_REF_(t).pack());
		}
		XTAL_DEF_(return,inline,met)
		operator, (subtype const  &s, packed_q auto &&t)
		noexcept -> auto
		{
			return bond::repack_f<packed_t>(XTAL_REF_(s).self().pack(), XTAL_REF_(t).pack());
		}

	};
	using type = subtype<any_type>;

};

///\
Defines an `inferred` tuple from `...Ts`, \
or `bond::seek_front_t<Ts...>` if `any_q<Ts...>` and `1 == sizeof...(Ts)`. \

template <class ...Ts>	struct   packet    : packed<Ts...> {};
template <any_q    T >	struct   packet<T> : identity_t<T> {};
template <class ...Ts>	using    packet_t = typename packet<Ts...>::type;

auto constexpr packet_f = []<class ...Ts> (Ts &&...ts)
XTAL_0FN_(to) (packet_t<Ts...>(static_cast<Ts &&> (ts)...));

///\
Defines a `conferred` value from `T`, \
or `T` if `any_q<T>`. \

template <class   ...Ts>	struct   let : let<either_t<Ts...>> {};
template <class      T >	struct   let<T>       {using type = conferred_t<T>;};
template <any_q      T >	struct   let<T>       {using type =             T ;};
template <             >	struct   let< >       {using type =  confined_t< >;};
template <class   ...Ts>	using    let_t      = typename let<Ts...>::type;

/*/
auto constexpr let_f = []<class ...Ts> (Ts &&...ts)
XTAL_0FN_(to) (let_t<Ts...>(static_cast<Ts &&> (ts)...));
/*/
template <class   ...Ts>
XTAL_DEF_(return,inline,let)
let_f(Ts &&...ts)
noexcept -> decltype(auto)
{
	return let_t<Ts...>(XTAL_REF_(ts)...);
}
/***/


////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
