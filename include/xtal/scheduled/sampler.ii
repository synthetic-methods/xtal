#pragma once
#include "./any.ii"

#include "../message/packet.ii"
#include "../process/any.hh"
#include "../processor/any.hh"
#include "../resourced/all.ii"

XTAL_ENV_(push)
namespace xtal::scheduled
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

///\
Provides an (in)queue for `X` on the target object, \
which is converted to a signal by successive calls to `method`. \

///\todo\
Adapt to provide polling. \

template <typename ...As>
struct sampler
{
	using subkind = common::compose<As..., resourced::respool<-1>>;

	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		using S_ = common::compose_s<S, subkind>;
		static_assert(resourced::respool_q<S_>);

	public:
		using S_::S_;

		template <class X>
		struct inqueue
		{
			using subkind = typename S_::template inqueue<X>;

			template <process::any_q R>
			class subtype: public common::compose_s<R, subkind>
			{
				using R_ = common::compose_s<R, subkind>;
			
			protected:
				using typename R_::tuple_t;
				using typename R_::tuple_u;
				using typename R_::event_u;
				using typename R_::delay_u;
				using spool_u = typename S_::template spool_t<event_u>;

				delay_u d_{0};
				spool_u q_{event_u::template sentry<-1>(), event_u::template sentry<1>()};

			public:
				using R_::R_;

				XTAL_TN0 ingest(event_u dot)
				XTAL_0EX
				{
					if (dot.head() < d_ and q_.empty()) {
						(void) q_.abandon().head(d_ = 0);
					}
					q_.push(XTAL_MOV_(dot));
				}

				XTAL_TN2 method()
				XTAL_0EX
				{
					return q_.advance(d_++ == q_.peek(1).head()).core().head();
				}

				///\todo\
				Use `tuple_u=serial` to provide an incremental Dual pair, \
				replacing the first-derivative with the minimum w.r.t. the current difference. \
				\
				Should be straightforward to parameterize with e.g. `<N_ramping=0>`, \
				respectively enabling/disabling if the goal has/hasn't been met. \

				///\todo\
				Once the phasor-type is settled, define a `method` that updates only on reset. \

				///\todo\
				Override immediate-dispatch `influx` to enqueue the current value? \

			};
		};

	};
};
template <class X>
using sampler_t = confined_t<sampler<X>>;


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
