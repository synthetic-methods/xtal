#pragma once
#include "./any.ii"

#include "../message/packet.ii"
#include "../process/any.hh"
#include "../processor/any.hh"
#include "../resourced/all.ii"

XTAL_ENV_(push)
namespace xtal::scheduled
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

///\
Provides an `in(flux )queue` for `X` on the target object, \
which produces a signal by successive calls to `method`. \

///\todo\
Adapt to provide polling. \

template <typename ...As>
struct polled
{
	using subkind = bond::compose<As..., resourced::spooled<-1>>;

	template <any_q S>
	class subtype: public bond::compose_s<S, subkind>
	{
		using S_ = bond::compose_s<S, subkind>;
		static_assert(resourced::spooled_q<S_>);

	public:
		using S_::S_;

		template <class X>
		struct inqueue
		{
			using subkind = typename S_::template inqueue<X>;

			template <process::any_q R>
			class subtype: public bond::compose_s<R, subkind>
			{
				using R_ = bond::compose_s<R, subkind>;
			
			protected:
				using typename R_::V_tuple;
				using typename R_::U_tuple;
				using typename R_::U_event;
				using typename R_::U_delay;
				using U_spool = typename S_::template spool_t<U_event>;

				U_delay __delay {0};
				U_spool __queue {U_event::template sentry<-1>(), U_event::template sentry<1>()};

			public:
				using R_::R_;

				XTAL_TN0 ingest(U_event u_event)
				XTAL_0EX
				{
					if (u_event.head() < __delay and __queue.empty()) {
						(void) __queue.abandon().head(__delay = 0);
					}
					__queue.push(XTAL_MOV_(u_event));
				}

				XTAL_TN2 method()
				XTAL_0EX
				{
					return __queue.advance(__delay++ == __queue.peek(1).head()).core().head();
				}

				///\todo\
				Use `U_tuple=serial` to provide an incremental Dual pair, \
				replacing the first-derivative with the minimum w.r.t. the current difference. \
				\
				Should be straightforward to parameterize with e.g. `<N_ramping=0>`, \
				respectively enabling/disabling if the goal has/hasn't been met. \

				///\todo\
				Once the phasor-type is settled, define a `method` that updates only on reset. \

				///\todo\
				Override immediate-dispatch `influx` to enqueue the current value? \

			};
		};

	};
};
template <class X>
using polled_t = confined_t<polled<X>>;


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
