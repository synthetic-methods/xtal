#pragma once
#include "./any.hh"






XTAL_ENV_(push)
namespace xtal::conflux
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

template <class T>
struct define
{
	using subkind = _retail::define<T>;

	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		friend T;
		using _S = common::compose_s<S, subkind>;
	
	public:
		using _S::_S;
		using _S::self;

		XTAL_TN1_(size_s) delay()         {return count_f(self());}
		XTAL_TN1_(size_s) relay(size_s i) {return count_f(self());}
		
		///\
		Relays all queued events while invoking the supplied callback for each intermediate segment. \
		The callback parameters are the `ranges::slice` indicies and the segment index. \

		XTAL_TLX reflux(auto const &f)
		XTAL_0EX
		{
			return reflux(f, 0);
		}
		XTAL_TLX reflux(auto const &f, auto &&n)
		XTAL_0EX
		{
			return reflux(f, n);
		}
		XTAL_TLX reflux(auto const &f, auto &n)
		XTAL_0EX
		{
			auto flx = -1;
			auto  &s = self();
			for (size_s i = 0, j = s.delay(); i != j; j = s.relay(i = j)) {
				flx &= f(n++, counted_f(i, j));
			}
			--n;
			return flx;
		}


		///\
		Influx operator: resolves the message for `this` before any dependencies, \
		used for e.g. `message::resize`. \

		XTAL_OP1 <<=(XTAL_DEF o)
		XTAL_0EX
		{
			(void) self().influx(XTAL_REF_(o));
			return self();
		}
		XTAL_OP1 <<=(XTAL_DEF_(common::heteropack_q) oo)
		XTAL_0EX
		{
			(void) _std::apply([this] XTAL_1FN_(self().influx), XTAL_REF_(oo));
			return self();
		}
		///\
		Influx handler: resolves the message for `this` before any dependencies. \
		
		///\returns the result of `infuse` applied to the first argument \
		`&` `influx` applied to the remaining arguments if successful. \

		XTAL_TLX influx(XTAL_DEF o, XTAL_DEF ...oo)
		XTAL_0EX
		{
			return XTAL_FLX_(self().influx(oo...)) (self().infuse(XTAL_REF_(o)));
		}
		XTAL_TLX influx(null_t, XTAL_DEF ...oo)
		XTAL_0EX
		{
			return influx();
		}
		XTAL_TLX influx()
		XTAL_0EX
		{
			return -1;
		}


		///\
		Efflux operator: resolves the message for any dependencies before `this`, \
		used for e.g. `message::respan` and `message::scope`. \

		XTAL_OP1 >>=(XTAL_DEF o)
		XTAL_0EX
		{
			(void) self().efflux(XTAL_REF_(o));
			return self();
		}
		XTAL_OP1 >>=(XTAL_DEF_(common::heteropack_q) oo)
		XTAL_0EX
		{
			(void) _std::apply([this] XTAL_1FN_(self().efflux), XTAL_REF_(oo));
			return self();
		}
		///\
		Efflux handler: resolves the message for any dependencies before `this`. \
		
		///\returns the result of `effuse` applied to the first argument \
		`&` `efflux` applied to the remaining arguments if successful. \

		XTAL_TLX efflux(XTAL_DEF o, XTAL_DEF ...oo)
		XTAL_0EX
		{
			return XTAL_FLX_(self().efflux(oo...)) (self().effuse(XTAL_REF_(o)));
		}
		XTAL_TLX efflux(null_t, XTAL_DEF ...oo)
		XTAL_0EX
		{
			return efflux();
		}
		XTAL_TLX efflux()
		XTAL_0EX
		{
			return -1;
		}


		///\
		Defuse handler: resolves the individual components of the message. \
		
		///\returns a ternary integer indicating that the state has changed (`0`), \
		remains unchanged (`1`), or that the message was unrecognized (`-1`). \
		
		///\note\
		The return values are accumulated using `&`, with a default of `-1` and limit of `0`, \
		and truncating propagation when the aggregated result is `1`. \

		XTAL_TLX defuse(XTAL_DEF o)
		XTAL_0EX
		{
			return -1;
		}
		XTAL_TLX effuse(XTAL_DEF o) XTAL_0EX {return self().defuse(XTAL_REF_(o));}
		///\< \see `defuse`. \

		XTAL_TLX infuse(XTAL_DEF o) XTAL_0EX {return self().defuse(XTAL_REF_(o));}
		///\< \see `defuse`. \
		

		///\
		Provides a `defer`red instance of `T` on `subtype`, \
		labelled with the given `As...`. \

		template <typename ...As>
		struct afflux
		{
			using subkind = common::compose<any<As>..., defer<T>>;

			template <conflux::any_q R>
			class subtype: public common::compose_s<R, subkind>
			{
				using _R = common::compose_s<R, subkind>;
			
			public:
			//	using _R::_R;
				using _R::self;

				XTAL_CO0_(subtype);
				XTAL_CO4_(subtype);

				///\
				Constructs the `attach`ed `message` using its default, \
				before `forward`ing the arguments to `this`. \

				XTAL_CXN subtype(XTAL_DEF ...xs)
				XTAL_0EX
				:	_R(T{}, XTAL_REF_(xs)...)
				{}

			};
		};

	};
};
template <class T>
struct refine
:	_retail::refine<T>
{
};


////////////////////////////////////////////////////////////////////////////////

template <class U>
struct defer
{
	using subkind = _retail::defer<U>;

	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		using _S = common::compose_s<S, subkind>;
	
	public:
		using _S::_S;
		using _S::self;
		using _S::head;

		///\note\
		Influxes the proxied value if supported, then `this`.

		XTAL_TLX influx(XTAL_DEF ...oo)
		XTAL_0EX
		XTAL_REQ any_q<U>
		{
			return XTAL_FLX_(_S::influx(oo...)) (head().influx(XTAL_REF_(oo)...));
		}
		XTAL_TLX influx(XTAL_DEF ...oo)
		XTAL_0EX
		{
			return _S::influx(XTAL_REF_(oo)...);
		}

		///\note\
		Effluxes `this`, then the proxied value if supported.

		XTAL_TLX efflux(XTAL_DEF ...oo)
		XTAL_0EX
		XTAL_REQ any_q<U>
		{
			return XTAL_FLX_(head().efflux(oo...)) (_S::efflux(XTAL_REF_(oo)...));
		}
		XTAL_TLX efflux(XTAL_DEF ...oo)
		XTAL_0EX
		{
			return _S::efflux(XTAL_REF_(oo)...);
		}

		///\note\
		Assigns the given value `u` if it matches the proxied type `U`. \

		XTAL_TLX defuse(U u)
		XTAL_0EX
		{
			return _S::heading(u) or (_S::head(u), 0);
		}
		XTAL_TLX defuse(XTAL_DEF w)
		XTAL_0EX
		{
			return _S::defuse(XTAL_REF_(w));
		}

	};
};
template <class U>
struct refer
:	_retail::refer<U>
{
};


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

template <class  X, any_q Y> XTAL_OP2 << (X &&x, Y &&y) XTAL_0EX {return _std::make_tuple(XTAL_REF_(x), XTAL_REF_(y));}
template <class  X, any_q Y> XTAL_OP2 >> (X &&x, Y &&y) XTAL_0EX {return _std::make_tuple(XTAL_REF_(y), XTAL_REF_(x));}

template <common::pack_q X, any_q Y> XTAL_OP2 << (X &&x, Y &&y) XTAL_0EX {return _std::tuple_cat(XTAL_REF_(x), _std::make_tuple(XTAL_REF_(y)));}
template <common::pack_q X, any_q Y> XTAL_OP2 >> (X &&x, Y &&y) XTAL_0EX {return _std::tuple_cat(_std::make_tuple(XTAL_REF_(y)), XTAL_REF_(x));}


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
