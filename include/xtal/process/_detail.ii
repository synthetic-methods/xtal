namespace _detail
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

using namespace _retail::_detail;


////////////////////////////////////////////////////////////////////////////////

template <typename ...As>
struct invoke_head
{
	using superkind = bond::compose<As...>;

	template <class S>
	class subtype : public bond::compose_s<S, superkind>
	{
		static_assert(any_q<S>);
		using S_ = bond::compose_s<S, superkind>;
		using U_ = typename S_::head_type;
		static_assert(complete_q<U_>);

		template <auto ...Is>
		XTAL_DEF_(short,static)
		XTAL_LET U_method(auto &&...xs)
		noexcept -> decltype(auto)
		requires             requires {U_::template static_method<Is...>(XTAL_REF_(xs)...);}
		or                   requires {U_::         static_method       (XTAL_REF_(xs)...);}
		or                   requires {U_{}                             (XTAL_REF_(xs)...);}
		{
			XTAL_IF0
			XTAL_0IF XTAL_TRY_(return) (U_::template static_method<Is...>(XTAL_REF_(xs)...)) 
			XTAL_0IF XTAL_TRY_(return) (U_::         static_method       (XTAL_REF_(xs)...)) 
			XTAL_0IF XTAL_TRY_(return) (U_{}                             (XTAL_REF_(xs)...)) 
		}

	public:// CONSTRUCT
		using S_::S_;

	public:// ACCESS
		using S_::head;

	public:// OPERATE

		template <auto ...Is>
		XTAL_DEF_(short,static)
		XTAL_LET static_method(auto &&...xs)
		noexcept -> decltype(auto)
		requires XTAL_TRY_(return) (U_method<Is...>(XTAL_REF_(xs)...))
		
	//	template <auto ...Is>
	//	XTAL_DEF_(short,static)
	//	XTAL_LET method(auto &&...xs)
	//	noexcept -> decltype(auto)
	//	requires XTAL_TRY_(return) (U_method<Is...>(XTAL_REF_(xs)...))

		template <auto ...Is>
		XTAL_DEF_(short)
		XTAL_LET method(auto &&...xs) const
		noexcept -> decltype(auto)
	//	requires XTAL_TRY_(void)   (U_method<Is...>(XTAL_REF_(xs)...))
		{
			XTAL_IF0
			XTAL_0IF  XTAL_TRY_(return) (head().template operator()<Is...>(XTAL_REF_(xs)...))
			XTAL_0IF  XTAL_TRY_(return) (head().template method    <Is...>(XTAL_REF_(xs)...))
			XTAL_0IF  XTAL_TRY_(return) (head().template operator()       (XTAL_REF_(xs)...))
			XTAL_0IF  XTAL_TRY_(return) (head().         method           (XTAL_REF_(xs)...))
			XTAL_0IF_(else)    {return   head(); static_assert(0 == sizeof...(xs));}
		}
		template <auto ...Is>
		XTAL_DEF_(short)
		XTAL_LET method(auto &&...xs)
		noexcept -> decltype(auto)
	//	requires XTAL_TRY_(void)   (U_method<Is...>(XTAL_REF_(xs)...))
		{
			XTAL_IF0
			XTAL_0IF  XTAL_TRY_(return) (head().template operator()<Is...>(XTAL_REF_(xs)...))
			XTAL_0IF  XTAL_TRY_(return) (head().template method    <Is...>(XTAL_REF_(xs)...))
			XTAL_0IF  XTAL_TRY_(return) (head().template operator()       (XTAL_REF_(xs)...))
			XTAL_0IF  XTAL_TRY_(return) (head().         method           (XTAL_REF_(xs)...))
			XTAL_0IF_(else)    {return   head(); static_assert(0 == sizeof...(xs));}
		}

	};
};


////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
