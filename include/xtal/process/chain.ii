#pragma once
#include "./any.ii"






XTAL_ENV_(push)
namespace xtal::process
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <typename ..._s> XTAL_NYM chain;
template <typename ..._s> XTAL_USE chain_t = confined_t<chain<_s...>>;


////////////////////////////////////////////////////////////////////////////////
///\
Composes both the `method`s and `static function`s defined by `As...`. \

///\note\
Template arguments are forwarded to each link. \

///\todo\
Accommodate `operator()` composition as well? \


template <class ...As>
struct chain;

template <>
struct chain<>
{
	template <class S>
	class subtype: public bond::compose_s<S>
	{
		using S_ = bond::compose_s<S>;

	public:
		using S_::S_;

	public:
		template <auto ...Is>
		XTAL_FN2 function(auto &&o)
		XTAL_0EX
		{
			return XTAL_FWD_(o);
		}

	};
};
template <>
struct chain<void>
{
	template <class S>
	using subtype = bond::compose_s<S>;

};
template <class A>
struct chain<A>
{
	using subkind = defer<A>;

	template <class S>
	class subtype: public bond::compose_s<S, subkind>
	{
		using S_ = bond::compose_s<S, subkind>;

	public:
		using S_::S_;

	public:
		XTAL_DO2_(template <auto ...Is>
		XTAL_TN2 method(auto &&...xs),
		{
			auto  &that = S_::head();
			return that.template method<Is...>(XTAL_FWD_(xs)...);
		})
		template <auto ...Is>
		XTAL_FN2 function(auto &&...xs)
		XTAL_0EX
		{
			using  That = typename S_::template head_t<>;
			return That::template function<Is...>(XTAL_FWD_(xs)...);
		}

	};
};
template <class A, class ...As>
struct chain<A, As...>
{
	using subkind = bond::compose<defer<A>, chain<As...>>;
	
	template <class S>
	class subtype: public bond::compose_s<S, subkind>
	{
		using S_ = bond::compose_s<S, subkind>;

	public:
		using S_::S_;

	public:
		XTAL_DO2_(template <auto ...Is>
		XTAL_TN2 method(auto &&...xs),
		{
			auto  &that = S_::template head<0>();
			auto  &then = S_::template self<0>();
			return that.template method<Is...>(then.template method<Is...>(XTAL_FWD_(xs)...));
		})
		template <auto ...Is>
		XTAL_FN2 function(auto &&...xs)
		XTAL_0EX
		{
			using  That = typename S_::template head_t<cardinal_t<0>>;
			using  Then = typename S_::template self_s<cardinal_t<0>>;
			return That::template function<Is...>(Then::template function<Is...>(XTAL_FWD_(xs)...));
		}

	};
};
//template <unconfined_q A, class ...As>
//struct chain<A, As...>: chain<confined_t<A>, As...> {};


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
