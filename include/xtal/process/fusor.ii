#pragma once
#include "./any.ii"






XTAL_ENV_(push)
namespace xtal::process
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <           typename ..._s> XTAL_NYM fusor;
template <           typename ..._s> XTAL_ASK fusor_q = atom::tag_p<fusor, _s...>;
template <array_q W, typename ...As> XTAL_USE fusor_t = confined_t<fusor<W, As...>>;


////////////////////////////////////////////////////////////////////////////////
///\
Manages a differential value like `phasor`, \
providing evaluation/update via succession/replacement. \

template <array_q W, typename ...As>
struct fusor<W, As...>
{
	XTAL_USE U_ = _std::remove_extent_t<W>;
	XTAL_LET N_ = _std::       extent_v<W>;
	
	using W_vector = atom::solid::serial_t<W>;
	using W_indent = flux::indent_s<W_vector>;
	using subkind = atom::compose<atom::tag<fusor>
	,	_detail::refer_iterators<W_vector>
	,	typename W_indent::tunnel
	,	As...
	>;
	
	template <class S>
	class subtype: public atom::compose_s<S, subkind>
	{
		using S_ = atom::compose_s<S, subkind>;

	public:
		using S_::S_;
		using S_::self;
		using S_::head;
		
		///\
		Access by dynamic index. \
		
		XTAL_TO4_(XTAL_TN2 subscript(size_t i), head().subscript(i))

		///\
		Evaluation by succession. \
		
		XTAL_DO2_(template <auto ...Is> requires (not sizeof...(Is))
		XTAL_TN2 method(),
		{
			return ++head();
		})
		///\
		Evaluation by (possibly indented) replacement then succession. \
		
		XTAL_DO2_(template <auto ...Is> requires (not sizeof...(Is))
		XTAL_TN2 method(XTAL_DEF_(subarray_q<N_>) a),
		{
			(void) S_::influx(XTAL_REF_(a));
			return method();
		})
		
	//	using S_::infuse;
		///\
		Update by replacement. \
		
		XTAL_TLX infuse(XTAL_DEF o)
		XTAL_0EX
		{
			return S_::infuse(XTAL_REF_(o));
		}
		///\
		Update by indented replacement. \
		
		XTAL_TLX infuse(XTAL_DEF_(subarray_q<N_>) a)
		{
			using A = XTAL_TYP_(a);
			using B = typename flux::indent_s<A, N_ - arity_n<A>>;
			return S_::influx(B(XTAL_REF_(a)));
		}

		///\todo\
		Introduce `message::per` etc to manage downsampling \
		(by scalar/integer multiplication followed by normalization). \

	};
};


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
