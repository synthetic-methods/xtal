








namespace _detail
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

template <template <class, typename...> class Subtype>
struct compost
{
	template <class S, class ..._s>
	struct pseudokind
	{
		using type = Subtype<S, _s...>;

	};
	template <class S, class ..._s> requires none_q<_s...>
	struct pseudokind<S, _s...>
	{
		using type = Subtype<S>;

	};
	template <class S, class ..._s>
	using subtype = typename pseudokind<S, _s...>::type;
//	using subtype = Subtype<S, _s...>;
//	NOTE: `clang` can't instantiate unary alias-templates with `T, Ts...` (with `0 == sizeof...(Ts)`).

};
template <template <class, typename...> class Subtype>
concept compost_q = requires {typename compost<Subtype>;};

template <typename Subtyped>
concept compose_q = compost_q<Subtyped::template subtype>;


////////////////////////////////////////////////////////////////////////////////

template <class U_that, class U_this, class U_head=void>
struct query
{
	class type
	{
	public:
		template <class _,               class ...Is> struct duper :  U_that::template super<_,                       Is...> {};
		template <class _,               class ...Is> struct super                   : duper<_,                       Is...> {};
		template <class _,  liminal_q I, class ...Is> struct super<_, I,      Is...> : duper<null_t, subliminal_s<I>, Is...> {};
		template <class _, terminal_q I, class ...Is> struct super<_, I,      Is...> : super<U_this,                  Is...> {};
		template <class _,               class ...Is> struct super<_, U_head, Is...> : super<U_this,                  Is...> {};
		template <class _,               class ...Is> struct super<_, U_this, Is...> : super<U_this,                  Is...> {};

	};
	template <class S>
	class subtype : public S
	{
		using S_ = S;
		friend S_;
		friend U_that;
		friend U_this;

	public://protected:
		using typename S_::T_self;
	//	using typename S_::U_head;

	public:
		template <class _, class ...Is>
		using super = typename type::template super<_, Is...>;

	public:
		using S_::S_;

		template <class ...Is> using self_s = typename super<T_self, Is...>::type;
		template <class ...Is> using head_s = typename super<U_this, Is...>::type;
		template <class ...Is> using head_t = typename head_s<Is...>::U_head;

		using S_::self;
		using S_::head;
		
		XTAL_TO4_(template <class  ...Is> requires some_q<Is...>
		XTAL_TN2 self(auto &&...oo), S_::template self<self_s<Is...>>(XTAL_REF_(oo)...)
		)
		XTAL_TO4_(template <class  ...Is> requires some_q<Is...>
		XTAL_TN2 head(auto &&...oo), S_::template self<head_s<Is...>>().head(XTAL_REF_(oo)...)
		)
		XTAL_TO4_(template <size_t ...Is> requires some_n<Is...>
		XTAL_TN2 self(auto &&...oo), self<cardinal_t<Is>...>(XTAL_REF_(oo)...)
		)
		XTAL_TO4_(template <size_t ...Is> requires some_n<Is...>
		XTAL_TN2 head(auto &&...oo), head<cardinal_t<Is>...>(XTAL_REF_(oo)...)
		)

	};
};


////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
