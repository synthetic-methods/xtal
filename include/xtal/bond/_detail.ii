








namespace _detail
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

using namespace _retail::_detail;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

template <template <class, typename...> class Subtype>
struct compost
{
	template <class S, class ..._s>                               struct pseudokind           {using type = Subtype<S, _s...>;};
	template <class S, class ..._s> requires (0 == sizeof...(_s)) struct pseudokind<S, _s...> {using type = Subtype<S       >;};
	template <class S, class ..._s>
	//\
	using subtype = Subtype<S, _s...>;
	using subtype = typename pseudokind<S, _s...>::type;
	//\note\
	Even when `not sizeof...(Ts)`, `clang` can't instantiate unary alias-templates with `T, Ts...`. \

};

template <typename T>
concept compose_q = complete_q<compost<T::template subtype>> and not requires {typename T::subtype;};


template <class S,          typename ...Ins> struct incompose;
template <                  typename ...Exs> struct excompose;

template <class S, class _, typename ...Ins> struct incompose<S, _, Ins...> : incompose<S, Ins...> {};
template <         class _, typename ...Exs> struct excompose<   _, Exs...> : excompose<   Exs...> {};

template <class S                          > struct incompose<S> {using type = S;};
template <                                 > struct excompose< > {template <class S, typename ...Ins> using subtype = typename incompose<S, Ins...>::type;};

template <class S, compose_q In, typename ...Ins>
struct incompose<S, In, Ins...>
:	incompose<typename In::template subtype<S>, Ins...>
{
};
template <         compose_q Ex, typename ...Exs>
struct excompose<Ex, Exs...>
{
	template <class S, typename ...Ins>
	using subtype = typename Ex::template subtype<
		typename excompose<Exs...>::template subtype<S, Ins...>
	>;

};


template <template <class, class...> class ...Subtypes>
using excompose_t = excompose<compost<Subtypes>...>;

template <class S, typename ...Ins>
using excompose_s = typename excompose<>::template subtype<S, Ins...>;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

template <class U_node, class U_edge=void>
struct query
{
	static bool constexpr Q_node =      same_q<void, U_edge>;
	static bool constexpr Q_edge = different_q<void, U_edge>;

	template <class S>
	class subtype : public S
	{
		using U_self = typename S::self_type;
		using U_null =             null_type;

	public:
		using node_type = U_node;

	public:
		template <class _,               class ...Is>                 struct   duper :       S::template super<_,                       Is...> {};
		template <class _,               class ...Is>                 struct   super                   : duper<_,                       Is...> {};
		template <class _,               class ...Is> requires Q_edge struct   super<_, U_edge, Is...> : duper<U_node,                  Is...> {};
		template <class _,  liminal_q I, class ...Is> requires Q_node struct   super<_, I,      Is...> : duper<U_null, subliminal_t<I>, Is...> {};
		template <class _, terminal_q I, class ...Is> requires Q_node struct   super<_, I,      Is...> : super<U_node,                  Is...> {};
		template <class _,               class ...Is> requires Q_node struct   super<_, U_node, Is...> : super<U_node,                  Is...> {};

		template <                       class ...Is> using  self_s = typename super<U_self, Is...>::type;

	public:
		using S::S;

		XTAL_FX4_(alias) (XTAL_DEF_(return,inline,get) node(), self<U_node>())

		XTAL_FX4_(alias) (template <size_type ...Is> requires (1 <= sizeof...(Is))
		XTAL_DEF_(return,inline,get) self(auto &&...oo), self<constant_t<Is>...>(XTAL_REF_(oo)...))
		
		XTAL_FX4_(alias) (template <class     ...Is> requires (0 == sizeof...(Is))
		XTAL_DEF_(return,inline,get) self(auto &&...oo), S::self(XTAL_REF_(oo)...))
		
		XTAL_FX4_(alias) (template <class     ...Is> requires (1 <= sizeof...(Is))
		XTAL_DEF_(return,inline,get) self(auto &&...oo), S::template self<self_s<Is...>>(XTAL_REF_(oo)...))

	};
	template <class S> requires complete_q<typename S::head_type>
	class subtype<S> : public S
	{
		using U_self = typename S::self_type;
		using U_head = typename S::head_type;
		using U_null =             null_type;

	public:
		using node_type = U_node;

	public:
		template <class _,               class ...Is>                 struct   duper :       S::template super<_,                       Is...> {};
		template <class _,               class ...Is>                 struct   super                   : duper<_,                       Is...> {};
		template <class _,               class ...Is> requires Q_edge struct   super<_, U_edge, Is...> : duper<U_node,                  Is...> {};
		template <class _,  liminal_q I, class ...Is> requires Q_node struct   super<_, I,      Is...> : duper<U_null, subliminal_t<I>, Is...> {};
		template <class _, terminal_q I, class ...Is> requires Q_node struct   super<_, I,      Is...> : super<U_node,                  Is...> {};
		template <class _,               class ...Is> requires Q_node struct   super<_, U_head, Is...> : super<U_node,                  Is...> {};
		template <class _,               class ...Is> requires Q_node struct   super<_, U_node, Is...> : super<U_node,                  Is...> {};
		/**/
		template <                       class ...Is> using  self_s = typename super<U_self, Is...>::type;
		template <                       class ...Is> using  head_s = typename super<U_node, Is...>::type;
		/*/
		template <                       class ...Is> using  self_s = complete_t<bond::tabbed_s<S, identity_t<U_edge>, identity_t<Is>...>, U_self>;
		template <                       class ...Is> using  head_s = complete_t<bond::tabbed_s<S, identity_t<U_edge>, identity_t<Is>...>, U_node>;
		/***/
		template <                       class ...Is> using  head_t = complete_t<typename head_s<Is...>::head_type, U_head>;

	public:
		using S::S;

		XTAL_FX4_(alias) (XTAL_DEF_(return,inline,get) node(), self<node_type>())


		XTAL_FX4_(alias) (template <size_type ...Is> requires (1 <= sizeof...(Is))
		XTAL_DEF_(return,inline,get) self(auto &&...oo), self<constant_t<Is>...>(XTAL_REF_(oo)...))
		
		XTAL_FX4_(alias) (template <class     ...Is> requires (0 == sizeof...(Is))
		XTAL_DEF_(return,inline,get) self(auto &&...oo), S::self(XTAL_REF_(oo)...))
		
		XTAL_FX4_(alias) (template <class     ...Is> requires (1 <= sizeof...(Is))
		XTAL_DEF_(return,inline,get) self(auto &&...oo), S::template self<self_s<Is...>>(XTAL_REF_(oo)...))
		

		XTAL_FX4_(alias) (template <size_type ...Is> requires (1 <= sizeof...(Is))
		XTAL_DEF_(return,inline,get) head(auto &&...oo), head<constant_t<Is>...>(XTAL_REF_(oo)...))

		XTAL_FX4_(alias) (template <class     ...Is> requires (0 == sizeof...(Is))
		XTAL_DEF_(return,inline,get) head(auto &&...oo), S::head(XTAL_REF_(oo)...))

		XTAL_FX4_(alias) (template <class     ...Is> requires (1 <= sizeof...(Is))
		XTAL_DEF_(return,inline,get) head(auto &&...oo), S::template self<head_s<Is...>>().head(XTAL_REF_(oo)...))

	};
};


////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
