#pragma once
#include "./any.ii"
#include "./lattice.ii"





XTAL_ENV_(push)
namespace xtal::bond
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <class ..._s> XTAL_NYM reciprocal;
template <class ..._s> XTAL_USE reciprocal_t = typename reciprocal<_s...>::type;
template <class ...Ts> XTAL_ASK reciprocal_q = atom::tagged_p<reciprocal, Ts...>;


////////////////////////////////////////////////////////////////////////////////
///\
Extends `lattice` with pointwise multiplication and an inner sum. \
This may be interpreted respectively as the Hadamard product and trace for diagonal matricies. \

///\note\
Represents the `dual_t` of `sector_t`. \

///\note\
Intended both to support dual time/frequency-domain processing, \
and to provide a basis for manipulating mutual inverses and odd/even pairs. \


template <class U, size_t N>
struct reciprocal<U[N]>
{
	using re = atom::realize<U>;
	
	template <class T>
	using demitype = typename lattice<U[N]>::template homotype<T>;

	template <class T>
	using hemitype = atom::compose_s<demitype<T>, atom::tag<reciprocal>>;

	template <class T>
	class homotype: public hemitype<T>
	{
		friend T;
		using S_ = hemitype<T>;
	
	public:
		using S_::S_;
		using S_::subscript;
		using S_::self;
		using S_::twin;

		template <class Z>
		using dual_t = Z;

		XTAL_OP1_(T &) *= (T const &t) XTAL_0EX {return atom::seek_forward_f<N>([&, this] (auto i) XTAL_0FN_(subscript(i) *= t.subscript(i))), self();}
		XTAL_OP1_(T &) /= (T const &t) XTAL_0EX {return atom::seek_forward_f<N>([&, this] (auto i) XTAL_0FN_(subscript(i) /= t.subscript(i))), self();}


		///\
		Sums the elements of `this` (equivalent to convolution by `{1}`). \

		XTAL_TN2 sum()
		XTAL_0FX
		{
			return [&, this]<auto ...M>(atom::seek_t<M...>)
				XTAL_0FN_(subscript(M) +...+ U())
			(atom::seek_f<N> {});
		}
		XTAL_TN2 dot()
		XTAL_0FX
		{
			return re::square_f(*this).sum();
		}
		XTAL_TN2 dot(iterated_q auto &&that)
		XTAL_0FX
		{
			return (twin() *= XTAL_FWD_(that)).sum();
		}

		
		///\returns the mutually inverse `lhs +/- rhs`, \
		scaled by the value indexed by `N_bias`: `{-1, 0, 1} -> {0.5, std::sqrt(0.5), 1.0}`. \
		
		///\todo\
		Generalize by taking the alternating sum for `N_par == -1`.

		template <int N_par=0>
		XTAL_TN2 reflected(int const n_bias=0)
		XTAL_0FX
		XTAL_REQ (N == 2)
		{
			auto const scale = re::explo_f(re::template unsquare_f<-1>(2), 1 - n_bias);
			auto const lhs = scale*subscript(0);
			auto const rhs = scale*subscript(1);
			if constexpr (N_par ==  0) {
				return T {lhs + rhs, lhs - rhs};
			}
			if constexpr (N_par == +1) {
				return lhs + rhs;
			}
			if constexpr (N_par == -1) {
				return lhs - rhs;
			}
		}
		///\
		Modifies `this`; \see `reflected()`.

		XTAL_TN2 reflect(int const n_bias=0)
		XTAL_0FX
		XTAL_REQ (N == 2)
		{
			return self() = reflected(n_bias);
		}

	};
	using type = atom::isotype<homotype>;

};


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
