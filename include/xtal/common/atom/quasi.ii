#pragma once
#include "./any.ii"
#include "./phase.ii"
#include "./pulse.ii"




XTAL_ENV_(push)
namespace xtal::common::atom
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <typename ..._s> XTAL_NYM quasi;
template <typename ..._s> XTAL_ASK quasi_q = common::tag_p<quasi, _s...>;
template <class U=size_t> XTAL_USE quasi_t = typename quasi<U>::type;


////////////////////////////////////////////////////////////////////////////////
///\
A `pulse, phase` used to represent e.g. `{phase/frequency, count/trigger}`. \

template <class U>
struct quasi<U>
{
	using _computer = common::compute<U>;

	template <class T>
	using hemitype = common::compose_s<unit_t, common::tag<quasi>, common::define<T>>;

	template <class T>
	class homotype: public hemitype<T>
	{
		friend T;
		using S_ = hemitype<T>;
	
	public:
		using S_::S_;
		using S_::self;
		using S_::twin;

		pulse_t<U> pulse; 
		phase_t<U> phase; 

		XTAL_TO4_(XTAL_OP0_(implicit) pulse_t<U>(), pulse)
		XTAL_TO4_(XTAL_OP0_(implicit) phase_t<U>(), phase)

		XTAL_TO4_(XTAL_OP0_(implicit) typename pulse_t<U>::value_type(), pulse.value)
		XTAL_TO4_(XTAL_OP0_(implicit) typename phase_t<U>::value_type(), phase.value)
	
		XTAL_CON homotype(XTAL_DEF_(pulse_value_q) o) XTAL_0EX: pulse(XTAL_REF_(o)) {}
		XTAL_CON homotype(XTAL_DEF_(phase_value_q) o) XTAL_0EX: phase(XTAL_REF_(o)) {}

		XTAL_OP2 + (XTAL_DEF w) XTAL_0FX {return twin() += XTAL_REF_(w);}
		XTAL_OP2 - (XTAL_DEF w) XTAL_0FX {return twin() -= XTAL_REF_(w);}
				
		XTAL_OP1 += (homotype const &t) XTAL_0EX {S_::pulse += t.pulse; S_::phase += t.phase; return self();}
		XTAL_OP1 -= (homotype const &t) XTAL_0EX {S_::pulse -= t.pulse; S_::phase -= t.phase; return self();}
	
	};
	using type = _detail::isotype<homotype>;

};


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
