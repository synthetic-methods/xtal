#pragma once
#include "./any.ii"






XTAL_ENV_(push)
namespace xtal::quantity
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <typename ..._s> XTAL_NYM fuse;
template <typename ..._s> XTAL_ASK fuse_q = atom::tag_p<fuse, _s...>;
template <class U=size_t> XTAL_USE fuse_t = confined_t<fuse<U>>;


////////////////////////////////////////////////////////////////////////////////
///\
Represents a mixable quantity of type `U`. \

template <additive_group_q U>
struct fuse<U>
{
	XTAL_LET_(U) _0 = 0;

	using subkind = confer<U, atom::tag<fuse>>;

	template <class S>
	class subtype: public atom::compose_s<S, subkind>
	{
		using S_ = atom::compose_s<S, subkind>;

	public:
		using S_::S_;
		using S_::self;

	//	XTAL_TO4_(XTAL_OP0_(implicit) U(), S_::head())// Only needed if `defer`red?

		XTAL_CO0_(subtype)
		XTAL_CO4_(subtype)
		XTAL_CON subtype(XTAL_DEF ...oo)
		XTAL_0EX
		:	S_(XTAL_REF_(oo)...)
		{
		//	self().commute(_0);
		}
		
		XTAL_TN1 commute(XTAL_DEF carry)
		XTAL_0EX
		{
			return self();
		}

		XTAL_OP2 + (XTAL_DEF w) XTAL_0FX {return S_::twin() += XTAL_REF_(w);}
		XTAL_OP2 - (XTAL_DEF w) XTAL_0FX {return S_::twin() -= XTAL_REF_(w);}
				
		XTAL_OP1 += (subtype const &t) XTAL_0EX {S_::operator+=(t.head()); return self().commute(_0);}
		XTAL_OP1 -= (subtype const &t) XTAL_0EX {S_::operator-=(t.head()); return self().commute(_0);}
	

	};
};


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
