//////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/**/
template <xtal::iterated_q T, ::std::invocable<xtal::iteratee_t<T>> U>
XTAL_OP2 | (T &&t, U &&u)
XTAL_0EX
{
	return XTAL_REF_(t)|::ranges::views::transform(XTAL_REF_(u));
};
/***/

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//\
Structural...

///\
Defines a factory for the supplied type. \

template <class T>
XTAL_LET make_f = [] XTAL_1FN_(T);


///\returns the compile-time size of the supplied array-like argument. \

template <class T>
XTAL_FN2 devalue_f(T &&t)
XTAL_0EX {return devalue_n<T>;}

template <class T> XTAL_REQ_(T::size())
XTAL_FN2 devalue_f(T &&)
XTAL_0EX {return T::size();}

template <class U, size_t N>
XTAL_FN2 devalue_f(U(&)[N])
XTAL_0EX {return N;}

template <class U, size_t N>
XTAL_FN2 devalue_f(_std::array<U, N> &&)
XTAL_0EX {return N;}

template <class U>
XTAL_FN2 devalue_f(_std::initializer_list<U> t)
XTAL_0EX {return devalue_n<decltype(_std::array{XTAL_REF_(t)})>;}



///\returns a higher-order function that applies its argument to the supplied `...xs`. \

XTAL_LET enforce_f = []<class ...Xs> (Xs &&...xs)
XTAL_0FN
{
	//\
	return [...xs = XTAL_REF_(xs)]
	return [&]
		(_std::invocable<Xs...> auto &&f) XTAL_0FN_(XTAL_REF_(f) (xs...));
};


/**/
///\returns the result of applying the `f` to `...xs`, \
zipping them together if vectorized. \

///\note\
Provides experimental support for `Eigen` (via `\.(?:un|bin|tern)aryExpr`), \
but can be specialized to support additional/custom data-types. \

///\todo\
Restric `eigenvalue_q` to `Array`-derived types.

XTAL_DEF_(return,inline)
XTAL_LET map_f(auto &&f)
XTAL_0EX
{	return _xtd::ranges::views::     generate(XTAL_REF_(f));
}
template <iterable_q X>
XTAL_DEF_(return,inline)
XTAL_LET map_f(auto &&f, X &&x)
XTAL_0EX
{	return _xtd::ranges::views::    transform(XTAL_REF_(x), XTAL_REF_(f));
}
template <iterable_q ...Xs>
XTAL_DEF_(return,inline)
XTAL_LET map_f(auto &&f, Xs &&...xs)
XTAL_0EX
{	return _xtd::ranges::views::zip_transform(XTAL_REF_(f), XTAL_REF_(xs)...);
}

#if __has_include(<Eigen/Core>)
template <eigenvalue_q X>
XTAL_DEF_(return,inline)
XTAL_LET map_f(auto &&f, X &&x)
XTAL_0EX
{	return XTAL_REF_(x).  unaryExpr(XTAL_REF_(f));
}
template <eigenvalue_q X, eigenvalue_q Y>
XTAL_DEF_(return,inline)
XTAL_LET map_f(auto &&f, X &&x, Y &&y)
XTAL_0EX
{	return XTAL_REF_(x). binaryExpr(XTAL_REF_(y), XTAL_REF_(f));
}
template <eigenvalue_q X, eigenvalue_q Y, eigenvalue_q Z>
XTAL_DEF_(return,inline)
XTAL_LET map_f(auto &&f, X &&x, Y &&y, Z &&z)
XTAL_0EX
{	return XTAL_REF_(x).ternaryExpr(XTAL_REF_(y), XTAL_REF_(z), XTAL_REF_(f));
}
#endif

template <class ...Xs>
XTAL_DEF_(return,inline)
XTAL_LET zap_f(auto &&f, Xs &&...xs)
XTAL_0EX
{
	using F = XTAL_TYP_(f);
	if constexpr (sizeof...(Xs) and _std::invocable<F, Xs...>) {
		return XTAL_REF_(f) (XTAL_REF_(xs)...);
	}
	else {
		return map_f(XTAL_REF_(f), XTAL_REF_(xs)...);
	}
}



template <auto f, class ...Xs>
XTAL_FN2 flex_f(Xs &&...xs)
XTAL_0EX
{	return f(XTAL_REF_(xs)...);
}

#if __has_include(<Eigen/Core>)
template <auto f, eigenvalue_q X>
XTAL_FN2 flex_f(X &&x)
XTAL_0EX
{	return XTAL_REF_(x).unaryExpr(f);
}
template <auto f, eigenvalue_q X, eigenvalue_q Y>
XTAL_FN2 flex_f(X &&x, Y &&y)
XTAL_0EX
{	return XTAL_REF_(x).binaryExpr(XTAL_REF_(y), f);
}
template <auto f, eigenvalue_q X, eigenvalue_q Y, eigenvalue_q Z>
XTAL_FN2 flex_f(X &&x, Y &&y, Z &&z)
XTAL_0EX
{	return XTAL_REF_(x).ternaryExpr(XTAL_REF_(y), XTAL_REF_(z), f);
}
#endif


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//\
Ranged...

template <counter_q  I >	XTAL_FN2 induced_f(I i0)       XTAL_0EX {return induced_t<I>(i0);}
template <counter_q  I >	XTAL_FN2 counted_f(I i0, I iN) XTAL_0EX {return counted_t<I>(i0, iN);}
template <class      T >	XTAL_FN2 counted_f(T &&t)      XTAL_0EX {return counted_t<T>(XTAL_REF_(t));}
template <class      T >	XTAL_FN2 counter_f(T &&t)      XTAL_0EX {return counter_t<T>(XTAL_REF_(t));}


///\returns the `size` of the given range. \

///\note\
If provided with an `iota_view`, \
returns a `value_type` instead of `size_type` which is twice the width. \

template <int N_offset=0, class T>
XTAL_DEF_(return,inline)
XTAL_LET point_f(T &&t)
XTAL_0EX
{
	using _xtd::ranges::begin;
	using _xtd::ranges::end;
	using _xtd::ranges::next;
	using _xtd::ranges::prev;
	
	if constexpr (iterator_q<T>) {
		if constexpr (0 == N_offset) {
			return XTAL_REF_(t); 
		}
		else {
			return next(XTAL_REF_(t), N_offset);
		}
	}
	else {
		if constexpr (0 <= N_offset) {
			return point_f<N_offset>(begin(XTAL_REF_(t)));
		}
		else {
			return point_f<N_offset>(  end(XTAL_REF_(t)));
		}
	}
}
template <class T>
XTAL_DEF_(return,inline)
XTAL_LET count_f(T &&t)
XTAL_0EX
{
	XTAL_IF0
	XTAL_0IF_(counter_q<T>) {
		return XTAL_REF_(t);
	}
	XTAL_0IF_(counted_q<T>) {
		return 1 + t.back() - XTAL_REF_(t).front();
	}
	XTAL_0IF_(bounded_q<T>) {
		return      t.end() - XTAL_REF_(t).begin();
	}
	XTAL_0IF_(requires {t.size();}) {
		return XTAL_REF_(t).size();
	}
	XTAL_0IF {
		return (size_t) 0;
	}
}
template <class T>
XTAL_DEF_(return,inline)
XTAL_FN1 account_f(T &&t)
XTAL_0EX
{
	using _xtd::ranges::views::take;
	return take(count_f(XTAL_REF_(t)));
}
template <class T>
XTAL_DEF_(return,inline)
XTAL_FN1 discount_f(T &&t)
XTAL_0EX
{
	using _xtd::ranges::views::drop;
	return drop(count_f(XTAL_REF_(t)));
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//\
Arithmetic...

template <class X, class Y>
XTAL_FN2 equal_f(X const &x, Y const &y)
XTAL_0EX
{
	return false;
}
template <class X, class Y> requires common_q<X, Y>
XTAL_FN2 equal_f(X const &x, Y const &y)
XTAL_0EX
{
	using W = common_t<X, Y>;
	return (W) x == (W) y;
}
template <class X, class Y> requires iterable_q<X, Y> and epimorphic_q<X, Y>
XTAL_FN2 equal_f(X &&x, Y &&y)
XTAL_0EX
{
	using _xtd::ranges::equal;

	return equal(XTAL_REF_(x), XTAL_REF_(y));
}

template <class X, class Y>
XTAL_FN2 equivalent_f(X &&x, Y &&y)
XTAL_0EX
{
	return equal_f(XTAL_REF_(x), XTAL_REF_(y));
}
template <class X, class Y> requires iterable_q<X, Y> and isomorphic_q<X, Y>
XTAL_FN2 equivalent_f(X const &x, Y const &y)
XTAL_0EX
{
	XTAL_IF0
	if constexpr (requires {x.begin() == y.begin() and x.end() == y.end();}) {
		return &x == &y or x.begin() == y.begin() and x.end() == y.end();
	}
	if constexpr (requires {x.begin() == y.begin();}) {
		return &x == &y or x.begin() == y.begin();
	}
	else {
		return &x == &y;
	}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#if not XTAL_SIC
class
{
public:
	XTAL_OP1() (auto &&...xs)
	{
		if constexpr (0 < sizeof...(xs)) {
			return (XTAL_REF_(xs), ...);
		}
	}

} echo;
#else
class
{
	XTAL_TN0 print_list(auto &&x)
	XTAL_0FX
	{
		for (auto &&w: XTAL_REF_(x)) ::std::cout << XTAL_REF_(w) << '\t';
	}
	XTAL_TN0 print_item(auto &&x)
	XTAL_0FX
	{
		using W = XTAL_TYP_(x);
		if constexpr (::std::is_floating_point_v<W>) {
			::std::cout.precision(17);
		}
		if constexpr (::std::is_arithmetic_v<W>) {
			if (::std::copysign(1.0, x) == 1.0) {
				 ::std::cout << ' ';
			}
		}
		::std::cout << XTAL_REF_(x) << '\t';
	}
	XTAL_TN1 put(auto &&x)
	XTAL_0FX
	{
		using W = XTAL_TYP_(x);
		if constexpr (_xtd::ranges::range<W> and requires {::std::is_arithmetic_v<typename W::value_type>;}) {
			print_list(XTAL_REF_(x));
		}
		else {
			print_item(XTAL_REF_(x));
		}
		return XTAL_REF_(x);
	}

public:
	XTAL_OP1() (auto &&...xs)
	XTAL_0FX
	{
		if constexpr (0 < sizeof...(xs)) {
			::std::cout << '\t'; auto const x = (put(XTAL_REF_(xs)), ...);
			::std::cout << '\n';
			return x;
		}
		else {
			::std::cout << '\n';
		}
	}

} const echo;
#endif


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
