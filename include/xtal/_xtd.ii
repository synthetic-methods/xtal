








namespace _xtd
{///////////////////////////////////////////////////////////////////////////////
//using namespace _std::experimental;

#if XTAL_VER_(ranges != 3)
namespace ranges        {using namespace ::std::ranges;}
namespace ranges::views {using namespace ::std::ranges::views;}
#else
namespace ranges        {using namespace      ::ranges;}
namespace ranges::views {using namespace      ::ranges::views;}
namespace ranges::views
{
	XTAL_DEF_(inline,let)
	zip_transform(auto &&...oo)
	noexcept -> decltype(auto)
	{
		return zip_with(XTAL_REF_(oo)...);
	}
}
#endif

template <class T> concept trivially_destructible  = _std::           is_trivially_destructible_v<T>;
//\
template <class T> concept trivially_movable       = _std::                is_trivially_movable_v<T>;
template <class T> concept trivially_movable       = _std::     is_trivially_move_constructible_v<T> and _std::is_trivially_move_assignable_v<T>;
//\
template <class T> concept trivially_copyable      = _std::               is_trivially_copyable_v<T>;
template <class T> concept trivially_copyable      = _std::     is_trivially_copy_constructible_v<T> and _std::is_trivially_copy_assignable_v<T>;
//\
template <class T> concept trivially_initializable = _std::               default_initializable  <T>;
template <class T> concept trivially_initializable = _std::  is_trivially_default_constructible_v<T>;

template <class T> concept trivially_constructible = trivially_copyable<T> and trivially_movable<T>;

template <class T> concept semitrivial = _std::semiregular<T> and     _std::destructible<T>;
template <class T> concept     trivial =       semitrivial<T> and trivially_destructible<T> and trivially_constructible<T>;

#if __cpp_lib_bit_cast
using _std::bit_cast;
#else
template <trivial T, trivial S> requires in_n<sizeof(T), sizeof(S)>
XTAL_DEF_(return,inline,let)
bit_cast(S s)
noexcept -> T
{
	return __builtin_bit_cast(T, s);
}
#endif

#if XTAL_VER_(STD < 2300) or XTAL_VER_(MSVC < 1700)
template <trivial T>
XTAL_DEF_(return,inline,let)
copysign(T t, T s)
noexcept -> T
{
	return __builtin_copysign(t, s);
}
#else
using _std::copysign;
#endif


////////////////////////////////////////////////////////////////////////////////

template <class F, class ...Xs> concept          invocable = requires {XTAL_ANY_(F)  (XTAL_ANY_(Xs)...);};
template <class F, class ...Xs> concept constant_invocable = requires {          F{} (XTAL_ANY_(Xs)...);};


template <class T>     using   make_signed   = _std::  make_signed  <T>;
template <class T>     using   make_signed_t = _std::  make_signed_t<T>;
XTAL_DEF_(return,inline,let)   make_signed_f  (_std::       signed_integral auto i) noexcept -> auto {return i;}
XTAL_DEF_(return,inline,let)   make_signed_f  (_std::     unsigned_integral auto i) noexcept -> auto {return bit_cast<  make_signed_t<decltype(i)>>(i);}
XTAL_DEF_(return,inline,let)   make_signed_f  (          constant_invocable auto f) noexcept -> auto {return   make_signed_f(f());}

template <class T>     using make_unsigned   = _std::make_unsigned  <T>;
template <class T>     using make_unsigned_t = _std::make_unsigned_t<T>;
XTAL_DEF_(return,inline,let) make_unsigned_f  (_std::       signed_integral auto i) noexcept -> auto {return bit_cast<make_unsigned_t<decltype(i)>>(i);}
XTAL_DEF_(return,inline,let) make_unsigned_f  (_std::     unsigned_integral auto i) noexcept -> auto {return i;}
XTAL_DEF_(return,inline,let) make_unsigned_f  (          constant_invocable auto f) noexcept -> auto {return make_unsigned_f(f());}


template <class T>	concept                rvalue_reference = _std::is_rvalue_reference_v<T>;
template <class T>	concept                lvalue_reference = _std::is_lvalue_reference_v<T>;

template <class T>	concept        trivial_rvalue_reference = rvalue_reference<T> and     trivial<_std::remove_cvref_t<T>>;
template <class T>	concept        trivial_lvalue_reference = lvalue_reference<T> and     trivial<_std::remove_cvref_t<T>>;

template <class T>	concept    semitrivial_rvalue_reference = rvalue_reference<T> and semitrivial<_std::remove_cvref_t<T>>;
template <class T>	concept    semitrivial_lvalue_reference = lvalue_reference<T> and semitrivial<_std::remove_cvref_t<T>>;

template <class T>	concept     nontrivial_rvalue_reference = _std::is_reference_v<T> and not     trivial_rvalue_reference<T>;
template <class T>	concept     nontrivial_lvalue_reference = _std::is_reference_v<T> and not     trivial_lvalue_reference<T>;

template <class T>	concept nonsemitrivial_rvalue_reference = _std::is_reference_v<T> and not semitrivial_rvalue_reference<T>;
template <class T>	concept nonsemitrivial_lvalue_reference = _std::is_reference_v<T> and not semitrivial_lvalue_reference<T>;

template <                       class T>	using                     remove_cvref    = _std:: remove_cvref  <T>;
template <                       class T>	using                     remove_cvref_t  = _std:: remove_cvref_t<T>;

template <                       class T>	struct             remove_rvalue_cvref    : _std::type_identity<T> {};
template <                       class T>	struct             remove_lvalue_cvref    : _std::type_identity<T> {};
template <            rvalue_reference T>	struct             remove_rvalue_cvref<T> :        remove_cvref<T> {};
template <            lvalue_reference T>	struct             remove_lvalue_cvref<T> :        remove_cvref<T> {};

template <                       class T>	struct     remove_trivial_rvalue_cvref    : _std::type_identity<T> {};
template <                       class T>	struct     remove_trivial_lvalue_cvref    : _std::type_identity<T> {};
template <    trivial_rvalue_reference T>	struct     remove_trivial_rvalue_cvref<T> :        remove_cvref<T> {};
template <    trivial_lvalue_reference T>	struct     remove_trivial_lvalue_cvref<T> :        remove_cvref<T> {};

template <                       class T>	struct remove_semitrivial_rvalue_cvref    : _std::type_identity<T> {};
template <                       class T>	struct remove_semitrivial_lvalue_cvref    : _std::type_identity<T> {};
template <semitrivial_rvalue_reference T>	struct remove_semitrivial_rvalue_cvref<T> :        remove_cvref<T> {};
template <semitrivial_lvalue_reference T>	struct remove_semitrivial_lvalue_cvref<T> :        remove_cvref<T> {};

template <class T>	 using              remove_rvalue_cvref_t = typename             remove_rvalue_cvref<T>::type;
template <class T>	 using              remove_lvalue_cvref_t = typename             remove_lvalue_cvref<T>::type;
template <class T>	 using      remove_trivial_rvalue_cvref_t = typename     remove_trivial_rvalue_cvref<T>::type;
template <class T>	 using      remove_trivial_lvalue_cvref_t = typename     remove_trivial_lvalue_cvref<T>::type;
template <class T>	 using  remove_semitrivial_rvalue_cvref_t = typename remove_semitrivial_rvalue_cvref<T>::type;
template <class T>	 using  remove_semitrivial_lvalue_cvref_t = typename remove_semitrivial_lvalue_cvref<T>::type;


template <                          class T>	struct      decay_nontrivial_reference    : remove_rvalue_cvref<T> {};
template <       trivial_lvalue_reference T>	struct      decay_nontrivial_reference<T> : remove_lvalue_cvref<T> {};
template <    nontrivial_lvalue_reference T>	struct      decay_nontrivial_reference<T>   {using type = _std::add_pointer_t<_std::remove_reference_t<T>>;};
template <                          class T>	using       decay_nontrivial_reference_t  = typename     decay_nontrivial_reference<T>::type;

template <                          class T>	struct  decay_nonsemitrivial_reference    : remove_rvalue_cvref<T> {};
template <   semitrivial_lvalue_reference T>	struct  decay_nonsemitrivial_reference<T> : remove_lvalue_cvref<T> {};
template <nonsemitrivial_lvalue_reference T>	struct  decay_nonsemitrivial_reference<T>   {using type = _std::add_pointer_t<_std::remove_reference_t<T>>;};
template <                          class T>	using   decay_nonsemitrivial_reference_t  = typename decay_nonsemitrivial_reference<T>::type;


////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
