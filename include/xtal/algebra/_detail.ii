








namespace _detail
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

using namespace _retail::_detail;


////////////////////////////////////////////////////////////////////////////////

template <template <class ...Us> class T>
struct build
{
//	NOTE: Can't define the default since it forces resolution of `objective_f` too early. \

	template <class V=void>
	XTAL_DEF_(return,inline)
	XTAL_FN1 via(auto &&...xs)
	XTAL_0EX
	XTAL_REQ common_q<decltype(xs)...>
	{
		if constexpr (complete_q<V>) {
			XTAL_SET f = invoke_f<V>;
			XTAL_USE F = invoke_t<V>;
			XTAL_USE U = common_t<decltype(xs)...>;
			XTAL_SET N = sizeof...(xs);
			if constexpr (idempotent_p<U, decltype(f)>) {
				return T<U[N]>{ (XTAL_REF_(xs))...};
			}
			else {
				return T<U[N]>{f(XTAL_REF_(xs))...};
			}
		}
		else {
			return via<decltype([] XTAL_1FN_(objective_f))>(XTAL_REF_(xs)...);
		}
	}

};

}//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
