








namespace _detail
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

using namespace _retail::_detail;


////////////////////////////////////////////////////////////////////////////////

template <class T>
struct aligned
{
	class type {alignas(alignof(T)) _std::byte data[sizeof(T)];};

	XTAL_DEF_(return,inline,set) size() noexcept -> decltype(auto) {return sizeof(type);}

};
template <class T             >	using          aligned_t =  typename aligned<T >::type;
template <         class ...Ts>	auto constexpr aligned_n =  (size_type{0} +...+ aligned<Ts>::size());
template <         class ...Ts>	auto constexpr aligned_m =  aligned_n<Ts...> - one;

template <class T>
XTAL_DEF_(return,inline,let)
maligned_f(auto &i)
noexcept -> auto
{
	using I = XTAL_ALL_(i);
	I constexpr N = aligned_n<T> << 3U;
	I constexpr M = N - 1;
	i += M; i &= ~M; auto const j = i; i += M; return j >> 3U;
};


////////////////////////////////////////////////////////////////////////////////

template <template <class ...Us> class T>
struct build
{
//	NOTE: Can't define the default since it forces resolution of `objective_f` too early. \

	template <auto f=null_type{}, class ...Xs>
	XTAL_DEF_(return,inline,set)
	with(Xs &&...xs)
	noexcept -> auto
	{
		using          F  =     invoke_t<decltype(f)>;
		using          X_ =           common_t<Xs...>;
		using          X0 = bond::seek_front_t<Xs...>;
		auto constexpr N  = sizeof...(xs);

		XTAL_IF0
		XTAL_0IF (incomplete_q<F>) {
		//	NOTE: Defining the default `f` here avoids eager-resolution which can prevent specialization...
		//	TODO: Use ADL instead?
			return with<[] XTAL_0FN_(alias) (objective_f)>(XTAL_REF_(xs)...);
		}
		XTAL_0IF (in_n<automorphism_p<F, X_>> and      same_q<Xs...>) {
			return T<return_t<F, X_>[N]>{ (XTAL_REF_(xs))...};
		}
		XTAL_0IF (un_n<automorphism_p<F, X_>> and      same_q<Xs...>) {
			return T<return_t<F, X_>[N]>{f(XTAL_REF_(xs))...};
		}
		XTAL_0IF (in_n<automorphism_p<F, X0>> and different_q<Xs...>) {
			return T<return_t<F, Xs>...>{ (XTAL_REF_(xs))...};
		}
		XTAL_0IF (un_n<automorphism_p<F, X0>> and different_q<Xs...>) {
			return T<return_t<F, Xs>...>{f(XTAL_REF_(xs))...};
		}
	}

};


////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
