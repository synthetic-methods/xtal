








namespace _detail
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

using namespace _retail::_detail;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

template <class T>
struct aligned
{
	class type {alignas(alignof(T)) byte_t data[sizeof(T)];};
	XTAL_LET value = sizeof(type);

};
template <class T> using    aligned_t = typename aligned<T>::type;
template <class T> XTAL_LET aligned_n =          aligned<T>::value;


template <iterator_q I >	XTAL_FN2    mover_f(I   i) XTAL_0EX {return _std::   make_move_iterator(i);}
template <iterator_q I >	XTAL_FN2 reverser_f(I   i) XTAL_0EX {return _std::make_reverse_iterator(i);}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

template <iterator_q Y_, iterator_q X_> requires isomorphic_q<Y_, X_>
XTAL_DEF_(inline)
XTAL_FN0 swap_with(Y_ y0, X_ const x0, X_ const xN, bool o=false)
XTAL_0EX
{
	using namespace _std;
#ifdef __cpp_lib_execution
	XTAL_SET seq = execution::  seq;
	XTAL_SET par = execution::unseq;
	if (o) swap_ranges(seq, x0, xN, y0);
	else   swap_ranges(par, x0, xN, y0);
#else
	swap_ranges(x0, xN, y0);
#endif
}
template <iterator_q Y_, bounded_q Xs>
XTAL_DEF_(inline)
XTAL_FN0 swap_with(Y_ y0, Xs const &xs, bool o=false)
XTAL_0EX
{
	swap_with(y0, xs.begin(), xs.end(), o);
}


////////////////////////////////////////////////////////////////////////////////

template <iterator_q Y_, iterator_q X_, _std::invocable<iteratee_t<X_>> F>
XTAL_DEF_(inline)
XTAL_FN0 copy_to(Y_ y0, X_ const x0, X_ const xN, F &&f, bool o=false)
XTAL_0EX
{
	using namespace _std;
#ifdef __cpp_lib_execution
	if (not _std::is_constant_evaluated()) {
		XTAL_SET seq = execution::  seq;
		XTAL_SET par = execution::unseq;
		if (o) transform(seq, x0, xN, y0, XTAL_REF_(f));
		else   transform(par, x0, xN, y0, XTAL_REF_(f));
	}
	else {
		transform(x0, xN, y0, XTAL_REF_(f));
	}
#else
	transform(x0, xN, y0, XTAL_REF_(f));
#endif
}
template <iterator_q Y_, bounded_q Xs, _std::invocable<iteratee_t<Xs>> F>
XTAL_DEF_(inline)
XTAL_FN0 copy_to(Y_ y0, Xs const &xs, F &&f, bool o=false)
XTAL_0EX
{
	copy_to(y0, xs.begin(), xs.end(), XTAL_REF_(f), o);
}
template <iterator_q Y_, iterator_q X_>
XTAL_DEF_(inline)
XTAL_FN0 copy_to(Y_ y0, X_ const x0, X_ const xN, bool o=false)
XTAL_0EX
{
	using Y = based_t<iteratee_t<Y_>>;
	copy_to(y0, x0, xN, invoke_f<Y>, o);
}
template <iterator_q Y_, iterator_q X_> requires isomorphic_q<Y_, X_>
XTAL_DEF_(inline)
XTAL_FN0 copy_to(Y_ y0, X_ const x0, X_ const xN, bool o=false)
XTAL_0EX
{
	using namespace _std;
#ifdef __cpp_lib_execution
	if (not _std::is_constant_evaluated()) {
		XTAL_SET seq = execution::  seq;
		XTAL_SET par = execution::unseq;
		if (o) copy(seq, x0, xN, y0);
		else   copy(par, x0, xN, y0);
	}
	else {
		copy(x0, xN, y0);
	}
#else
	copy(x0, xN, y0);
#endif
}
template <iterator_q Y_, bounded_q Xs>
XTAL_DEF_(inline)
XTAL_FN0 copy_to(Y_ y0, Xs const &xs, bool o=false)
XTAL_0EX
{
	using X_ = iterator_t<Xs>;
	using X  = iteratee_t<X_>;
	using Y  = iteratee_t<Y_>;
	if constexpr (is_q<Y_, X_> and alignof(Y) == alignof(X)) {
		_std::memcpy(y0, XTAL_REF_(xs).begin(), sizeof(xs));
	}
	else {
		copy_to(y0, xs.begin(), xs.end(), o);
	}
}


////////////////////////////////////////////////////////////////////////////////

template <iterator_q Y_, iterator_q X_, _std::invocable<iteratee_t<X_>> F>
XTAL_DEF_(inline)
XTAL_FN0 move_to(Y_ y0, X_ const x0, X_ const xN, F &&f, bool o=false)
XTAL_0EX
{
	copy_to(y0, mover_f(x0), mover_f(xN), XTAL_REF_(f), o);
}
template <iterator_q Y_, bounded_q Xs, _std::invocable<iteratee_t<Xs>> F>
XTAL_DEF_(inline)
XTAL_FN0 move_to(Y_ y0, Xs &&xs, F &&f, bool o=false)
XTAL_0EX
{
	move_to(y0, xs.begin(), xs.end(), XTAL_REF_(f), o);
}
template <iterator_q Y_, iterator_q X_>
XTAL_DEF_(inline)
XTAL_FN0 move_to(Y_ y0, X_ x0, X_ xN, bool o=false)
XTAL_0EX
{
	copy_to(y0, mover_f(x0), mover_f(xN), o);
}
template <iterator_q Y_, bounded_q Xs>
XTAL_DEF_(inline)
XTAL_FN0 move_to(Y_ y0, Xs &&xs, bool o=false)
XTAL_0EX
{
	using X_ = iterator_t<Xs>;
	using X  = iteratee_t<X_>;
	using Y  = iteratee_t<Y_>;
	if constexpr (is_q<Y_, X_> and alignof(Y) == alignof(X)) {
		_std::memmove(y0, XTAL_REF_(xs).begin(), sizeof(xs));
	}
	else {
		move_to(y0, xs.begin(), xs.end(), o);
	}
}


////////////////////////////////////////////////////////////////////////////////

template <class W, class F>
XTAL_DEF_(inline)
XTAL_FN0 apply_to(W &w, F &&f, bool o=false)
XTAL_0EX
{
	w = XTAL_REF_(f) (w);
}
template <class Ws, class F> requires bounded_q<Ws>
XTAL_DEF_(inline)
XTAL_FN0 apply_to(Ws &ws, F &&f, bool o=false)
XTAL_0EX
{
	if constexpr (bond::pack_q<Ws>) {
		bond::seek_forward_f<bond::pack_size_n<Ws>>([&] (auto I) XTAL_0FN {apply_to(get<I>(ws), f);});
	}
	else {
		move_to(ws.begin(), ws, XTAL_REF_(f), o);
	}
}


}//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
