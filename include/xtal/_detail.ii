namespace _detail
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//\
Standard...

using    null_t = XTAL_STD_(null_t);
using    unit_t = XTAL_STD_(unit_t);
using    sign_t = XTAL_STD_(sign_t);
using    byte_t = XTAL_STD_(byte_t);
using    size_t = XTAL_STD_(size_t);
using    size_s = XTAL_STD_(size_s);
XTAL_LET size_1 = (size_t) 1;

template <auto N_zero=0>
XTAL_LET    sign_f(auto &&i)
XTAL_0EX -> sign_t
{
	XTAL_IF0
	XTAL_0IF_(N_zero ==  0) {return (0 <  i) - (i <  0);}
	XTAL_0IF_(N_zero == +1) {return (0 <= i) - (i <  0);}
	XTAL_0IF_(N_zero == -1) {return (0 <  i) - (i <= 0);}
}

template <auto N, auto  ...Ms>	concept exclusive_p = (...and (N != Ms));
template <auto N, auto  ...Ms>	concept inclusive_p = (...or  (N == Ms));
template <auto N, auto  N_0=0>	concept      sign_p = inclusive_p<N, -1, N_0, 1>;
template <auto N, auto  N_0=0>	XTAL_LET     sign_n = sign_f<N_0>(N);

template <class         ...Ts>	concept  some_q = 0 < sizeof...(Ts);
template <auto          ...Ns>	concept  some_n = 0 < sizeof...(Ns);
template <class         ...Ts>	concept  none_q = not some_q<Ts...>;
template <auto          ...Ns>	concept  none_n = not some_n<Ns...>;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//\
Structural...

template <class      T             >	concept  incomplete_q = not requires {typename _std::void_t<decltype(sizeof(T))>;};
template <class      T             >	concept    complete_q = not incomplete_q<T>;
template <              class ...Ts>	struct     complete              {class type   {};};
template <class      T, class ...Ts>	struct     complete<T, Ts...> :  complete<Ts...> {};
template <complete_q T, class ...Ts>	struct     complete<T, Ts...>    {using type =  T;};
template <              class ...Ts>	using      complete_t = typename complete<Ts...>::type;


////////////////////////////////////////////////////////////////////////////////

template <class      T >	concept  constant_q = _std::derived_from<T, _std::integral_constant<typename T::value_type, T::value>>;
template <auto       N >	using    constant   = _std::integral_constant<decltype(N), N>;
template <auto       N >	using    cardinal   = _std::integral_constant<size_t,      N>;
template <auto       N >	using     ordinal   = _std::integral_constant<int,         N>;
template <auto       N >	using     logical   = _std::integral_constant<bool,        N>;

template <class      T >	concept _integral_p = _std::     integral  <T>;
template <class      T >	concept _cardinal_p = _std::  is_unsigned_v<T>;
template <class      T >	concept  _ordinal_p = _std::    is_signed_v<T>;
template <class      T >	concept  _logical_p = _std:: convertible_to<T, bool>;

template <class      T >	concept  integral_q =  constant_q<T> and _integral_p<typename T::value_type>;
template <class      T >	concept  cardinal_q =  constant_q<T> and _cardinal_p<typename T::value_type>;
template <class      T >	concept   ordinal_q =  constant_q<T> and  _ordinal_p<typename T::value_type>;
template <class      T >	concept   logical_q =  constant_q<T> and  _logical_p<typename T::value_type>;

template <class      T >	concept  integral_p =  integral_q<T>  or _integral_p<T>;
template <class      T >	concept  cardinal_p =  cardinal_q<T>  or _cardinal_p<T>;
template <class      T >	concept   ordinal_p =   ordinal_q<T>  or  _ordinal_p<T>;
template <class      T >	concept   logical_p =   logical_q<T>  or  _logical_p<T>;


template <class      T >	concept  terminal_q =  integral_q<T> and 0 == T::value;
template <class      T >	concept   liminal_q =  integral_q<T> and 0 != T::value;
template <liminal_q  T >	using  subliminal   = constant<(T{} - sign_n<T{}>)>;
template <liminal_q  T >	using semiliminal   = constant<(T{} >> 1)>;


////////////////////////////////////////////////////////////////////////////////

template <class      T >	using       based_t = _std::remove_cvref_t<complete_t<T>>;
template <class      T >	concept     based_q = _std::is_trivially_copyable_v<T> and
	_std::is_copy_constructible_v<T> and _std::is_copy_assignable_v<T> and
	_std::is_move_constructible_v<T> and _std::is_move_assignable_v<T> and
	true;
template <class      T >	concept   unbased_q = not based_q<T>;

template <class      T >	struct    debased            : logical<0> {using type = _std::remove_reference_t<T>;};
template <unbased_q  T >	struct    debased<T       &> : logical<1> {using type =       T*;};
template <unbased_q  T >	struct    debased<T const &> : logical<1> {using type = const T*;};
template <class      T >	concept   debased_q = (bool) debased<T>::value;

template <class      T >	struct    rebased            : logical<1> {using type = _std::remove_reference_t<T>;};
template <unbased_q  T >	struct    rebased<T       &> : logical<0> {using type =       T&;};
template <unbased_q  T >	struct    rebased<T const &> : logical<0> {using type = const T&;};
template <class      T >	concept   rebased_q = (bool) rebased<T>::value;


template <class      T >	concept   unvalue_q = requires {typename based_t<T>::value_type;};
template <unvalue_q  T >	using     unvalue_t =           typename based_t<T>::value_type;

template <class      T >	concept   invalue_q = not _std::same_as<based_t<T>, _std::remove_all_extents_t<based_t<T>>>;
template <invalue_q  T >	using     invalue_t =                               _std::remove_all_extents_t<based_t<T>> ;

template <class      T >	struct    devalue;
template <class      T >	using     devalue_t = typename devalue<based_t<T>>::type;
template <class      T >	XTAL_LET  devalue_n =          devalue<based_t<T>>::size;
template <class      T >	struct    devalue    {using type =                     T  ; XTAL_LET_(size_t) size =                      1;};
template <unvalue_q  T >	struct    devalue<T> {using type =           unvalue_t<T> ; XTAL_LET_(size_t) size = sizeof(T)/sizeof(type);};
template <invalue_q  T >	struct    devalue<T> {using type =           invalue_t<T> ; XTAL_LET_(size_t) size = sizeof(T)/sizeof(type);};
template <class      T >	concept   devalue_q = unvalue_q<T> or invalue_q<T>;

template <class      T >	struct    devolve;
template <class      T >	using     devolve_t = typename devolve<based_t<T>>::type;
template <class      T >	XTAL_LET  devolve_n =          devolve<based_t<T>>::size;
template <class      T >	struct    devolve    {using type =                     T  ; XTAL_LET_(size_t) size =                      1;};
template <devalue_q  T >	struct    devolve<T> {using type = devolve_t<devalue_t<T>>; XTAL_LET_(size_t) size = sizeof(T)/sizeof(type);};


////////////////////////////////////////////////////////////////////////////////

template <           class ...Ts>	struct    identical;// `is_same`
template <           class ...Ts>	struct    isotropic;// `is_same` modulo qualifiers
template <           class ...Ts>	struct    epitropic;// `is_constructible`

template <class  T , class ...Ts>	struct    identical<T, Ts...> : _std::conjunction<_std::is_same<Ts, T>...> {};
template <class  T , class ...Ts>	struct    isotropic<T, Ts...> : _std::conjunction<_std::is_same<based_t<Ts>, based_t<T>>...> {};
template <class  T , class ...Ts>	struct    epitropic<T, Ts...> : _std::conjunction<_std::is_constructible<Ts, T>...> {};

template <           class ...Ts>	concept          id_q = identical<Ts...>::value;
template <           class ...Ts>	concept          is_q = isotropic<Ts...>::value;
template <           class ...Ts>	concept          as_q = epitropic<Ts...>::value;
template <class  T , class ...Ys>	concept          as_p = _std::constructible_from<T, Ys...>;
template <class  T , class    Y >	concept    fungible_q = _std::derived_from<based_t<T>, based_t<Y>> or _std::derived_from<based_t<Y>, based_t<T>>;
template <class  T , class    Y >	concept  infungible_q = not fungible_q<T, Y>;

template <           class ...Ts>	concept      common_q = requires {typename _std::common_type_t<Ts...>;};
template <           class ...Ts>	using        common_t =                    _std::common_type_t<Ts...>;
template <class               X >	struct     argument     {using type = X      &&;};
template <based_q             X >	struct     argument<X>  {using type = X const &;};


////////////////////////////////////////////////////////////////////////////////

template <class      T >	concept     array_q = _std::is_array_v<T> or fungible_q<T, _std::array<devolve_t<T>, devalue_n<T>>>;

template <class      T >	concept  accessed_q = requires (T t) { t[XTAL_VAL_(size_t)];};
template <class      T >	concept   pointer_q = requires (T t) {*t;};
template <class      T >	using    accessed_t = _std::remove_reference_t<decltype( XTAL_VAL_(T)[XTAL_VAL_(size_t)])>;
template <class      T >	using     pointer_t = _std::remove_reference_t<decltype(&XTAL_VAL_(T))>;
template <class      T >	using     pointee_t = _std::remove_reference_t<decltype(*XTAL_VAL_(T))>;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//\
Ranged...

template <class         T >	concept     begin_q    = requires {*XTAL_VAL_(T).begin();};
template <class         T >	concept     front_q    = requires { XTAL_VAL_(T).front();};
template <class         T >	concept      back_q    = requires { XTAL_VAL_(T). back();};
template <class         T >	concept       end_q    = requires {*XTAL_VAL_(T).  end();};

template <class         T >	using       begin_t    = decltype ( XTAL_VAL_(T).begin() );
template <class         T >	using       front_t    = decltype (*XTAL_VAL_(T).begin() );
template <class         T >	using        back_t    = decltype (*XTAL_VAL_(T).  end() );
template <class         T >	using         end_t    = decltype ( XTAL_VAL_(T).  end() );

template <class         T >	concept   bounded_q    = begin_q<T> and     end_q<T>;
template <class         T >	concept unbounded_q    = begin_q<T> and not end_q<T>;

template <class         T >	concept   debrace_q    = requires {typename T::initializer_list;};
template <class         T >	concept reembrace_q    = debrace_q<T> or devalue_q<T>;
template <class         T >	struct  reembrace       {using type = _std::initializer_list<devalue_t<T>>;};
template <debrace_q     T >	struct  reembrace<T>    {using type = typename T::initializer_list;};
template <class         T >	using   reembrace_t    = typename reembrace<T>::type;
template <class         W >	using     embrace_t    = _std::initializer_list<W>;


template <class         W >	using    interval_t    = _v3::ranges::iota_view<W, W>;

template <class         T >	struct   iteratee;
template <class         T >	struct   iterated;
template <class         T >	struct   iterator;
template <class         T >	struct   sentinel;
template <class         T >	struct   distance;

template <class         T >	using    iteratee_t    = typename iteratee<T>::type;//_v3::ranges::range_reference_t, _v3::ranges::iter_reference_t
template <class         T >	using    iterated_t    = typename iterated<T>::type;
template <class         T >	using    iterator_t    = typename iterator<T>::type;//_v3::ranges::iterator_t
template <class         T >	using    sentinel_t    = typename sentinel<T>::type;
template <class         T >	using    distance_t    = typename distance<T>::type;

template <class         T >	concept  iteratee_q    = true;
template <class         T >	concept  iterable_q    = begin_q<T> and not front_q<T>;
template <class         T >	concept  iterated_q    = begin_q<T> and     front_q<T>;//_v3::ranges::forward_range
template <class         T >	concept  iterator_q    = requires (T t) {*++t;};//_v3::ranges::forward_iterator
template <class         T >	concept  sentinel_q    = iterator_q<T>;
template <class         T >	concept  distance_q    = integral_q<T>;//\todo Expand to accommodate `counted_t<size_t>{}.size()`.

template <class T, class Y>	concept  iteratee_of_q = is_q<iteratee_t<T>, Y>;
template <class T, class Y>	concept  iterable_of_q = iterable_q<T> and iteratee_of_q<T, Y>;
template <class T, class Y>	concept  iterated_of_q = iterated_q<T> and iteratee_of_q<T, Y>;
template <class T, class Y>	concept  iterator_of_q = iterator_q<T> and iteratee_of_q<T, Y>;
template <class T, class Y>	concept  sentinel_of_q = sentinel_q<T> and iteratee_of_q<T, Y>;
//mplate <class T, class Y>	concept  distance_of_q = distance_q<T> and iteratee_of_q<T, Y>;

template <iterable_q T    >	struct   iteratee<T>   {using type =     pointee_t<begin_t<T>>;};
template <iterated_q T    >	struct   iteratee<T>   {using type =     pointee_t<begin_t<T>>;};
template <iterator_q T    >	struct   iteratee<T>   {using type =     pointee_t<        T >;};
template <integral_p T    >	struct   iteratee<T>   {using type =               based_t<T> ;};

template <iterated_q T    >	struct   iterated<T>   {using type =               based_t<T> ;};
template <iterator_q T    >	struct   iterated<T>   {using type =                     void ;};
template <integral_p T    >	struct   iterated<T>   {using type =            interval_t<T> ;};

template <iterable_q T    >	struct   iterator<T>   {using type =               begin_t<T> ;};
template <iterated_q T    >	struct   iterator<T>   {using type =               begin_t<T> ;};
template <iterator_q T    >	struct   iterator<T>   {using type =               based_t<T> ;};
template <integral_p T    >	struct   iterator<T>   {using type = iterator_t<interval_t<T>>;};

template <iterable_q T    >	struct   sentinel<T>   {using type = end_t<T>;};//_v3::ranges::sentinel_t<T>;
template <iterated_q T    >	struct   sentinel<T>   {using type = end_t<T>;};//_v3::ranges::sentinel_t<T>;
template <iterator_q T    >	struct   sentinel<T>   {using type =       T ;};

template <class      T    >	struct   distance                   {using type = distance_t<iterator_t<T>>;};
template <iterator_q T    >	struct   distance<T>                {using type = XTAL_TYP_(_std::distance(XTAL_VAL_(T), XTAL_VAL_(T)));};


template <class         T >	concept  counter_q     = integral_p<T>;
template <class         T >	concept  counted_q     = iterated_q<T> and as_q<T, interval_t<iteratee_t<T>>>;

template <class         T >	struct   counted;
template <class         T >	struct   counter;

template <counted_q     T >	struct   counted<T>    {using type =    based_t<T>;};
template <counter_q     T >	struct   counted<T>    {using type = iterated_t<T>;};

template <counted_q     T >	struct   counter<T>    {using type = iteratee_t<T>;};
template <counter_q     T >	struct   counter<T>    {using type =    based_t<T>;};


template <class         T >	using reiterated_t     = _v3::ranges::subrange<iterator_t<T>, iterator_t<T>>;
template <class         T >	using initerated_t     = _v3::ranges::view_interface<T>;



////////////////////////////////////////////////////////////////////////////////

template <class      ...Ts>	struct   isomorphic        : isotropic<Ts...> {};
template <iterated_q ...Ts>	struct   isomorphic<Ts...> : isomorphic<iteratee_t<Ts>...> {};
template <iterator_q ...Ts>	struct   isomorphic<Ts...> : isomorphic<iteratee_t<Ts>...> {};

template <class      ...Ts>	struct   epimorphic        : epitropic<Ts...> {};
template <iterated_q ...Ts>	struct   epimorphic<Ts...> : epimorphic<iteratee_t<Ts>...> {};
template <iterator_q ...Ts>	struct   epimorphic<Ts...> : epimorphic<iteratee_t<Ts>...> {};


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//\
Arithmetic...

template <class      T >	concept   integral_number_q =  _std::integral      <based_t<T>>;
template <class      T >	concept       real_number_q =  _std::floating_point<based_t<T>>;
template <class      T >	concept    complex_number_q = fungible_q<T, _std::complex<unvalue_t<T>>> and real_number_q<unvalue_t<T>>;
template <class      T >	concept            number_q = integral_number_q<T> or real_number_q<T> or complex_number_q<T>;
template <class      T >	concept           numeric_q = requires {typename _std::numeric_limits<based_t<T>>;};
template <class      T >	using             numeric_t = _std::numeric_limits<devalue_t<T>>;


////////////////////////////////////////////////////////////////////////////////

template <size_t N_arity, class T, class U=T>
concept equality_p = requires (based_t<T> t, U u)
{
	requires N_arity == 2;
	{t == u} -> is_q<bool>;
	{t != u} -> is_q<bool>;
};
template <size_t N_arity, class T, class U=T>
concept inequality_p = equality_p<N_arity, T> and requires (based_t<T> t, U u)
{
	requires N_arity == 2;
	{t <= u} -> is_q<bool>;
	{t <  u} -> is_q<bool>;
	{t >= u} -> is_q<bool>;
	{t >  u} -> is_q<bool>;
};
template <size_t N_arity, class T, class U=T>
concept quality_p = equality_p<N_arity, T> and inequality_p<N_arity, T>;


template <size_t N_arity, class T, class U=T>
concept boolean_logic_p = requires (based_t<T> t, based_t<U> u)
{
	requires N_arity == 2 or requires
	{
		{!u} -> is_q<T>;
	};
	requires N_arity == 1 or requires
	{
		{t || u} -> is_q<T>;
		{t && u} -> is_q<T>;
	};
};
template <size_t N_arity, class T, class U=T>
concept binary_logic_p = requires (based_t<T> t, based_t<U> u)
{
	requires N_arity == 2 or requires
	{
		{   ~  u} -> is_q<T>;
		{t  ^= u} -> is_q<T>;
		{t  |= u} -> is_q<T>;
		{t  &= u} -> is_q<T>;
	};
	requires N_arity == 1 or requires
	{
		{t  ^  u} -> is_q<T>;
		{t  |  u} -> is_q<T>;
		{t  &  u} -> is_q<T>;
	};
};


template <size_t N_arity, class T, class U=T>
concept multiplicative_group_p = requires (based_t<T> t, based_t<U> u)
{
	requires N_arity == 2 or requires
	{
		{t  *= u} -> is_q<T>;
		{t  /= u} -> is_q<T>;
	};
	requires N_arity == 1 or requires
	{
		{t  *  u} -> is_q<T>;
		{t  /  u} -> is_q<T>;
	};
};
template <size_t N_arity, class T, class U=T>
concept additive_group_p = requires (based_t<T> t, based_t<U> u)
{
	requires N_arity == 2 or requires
	{
		{t  += u} -> is_q<T>;
		{t  -= u} -> is_q<T>;
	};
	requires N_arity == 1 or requires
	{
		{t  +  u} -> is_q<T>;
		{t  -  u} -> is_q<T>;
		{   -  u} -> is_q<T>;
	};
};
template <size_t N_arity, class T, class U=T>
concept discrete_group_p = requires (based_t<T> t, based_t<U> u)
{
	requires N_arity == 2 or requires
	{
		{t  ++  } -> is_q<T>;
		{   ++ u} -> is_q<T>;
		{t  --  } -> is_q<T>;
		{   -- u} -> is_q<T>;
	};
};
template <size_t N_arity, class T, class U=T>
concept quotient_group_p = requires (based_t<T> t, based_t<U> u)
{
	requires N_arity == 2 or requires
	{
		{t  %= u} -> is_q<T>;
	};
	requires N_arity == 1 or requires
	{
		{t  %  u} -> is_q<T>;
	};
};
template <size_t N_arity, class T, class U=T>
concept integral_group_p = integral_number_q<T> or discrete_group_p<N_arity, T> and quotient_group_p<N_arity, T>;


template <size_t N_arity, class T, class U=T>
concept plex_field_p = multiplicative_group_p<N_arity, T> and additive_group_p<N_arity, T>;

template <size_t N_arity, class T, class U=T>
concept real_field_p = real_number_q<T> or plex_field_p<N_arity, T> and requires (based_t<T> t)
{
	requires quality_p<2, T>;
	{_std::abs(t)} -> is_q<T>;
};

template <size_t N_arity, class T, class U=T>
concept complex_field_p = complex_number_q<T> or plex_field_p<2, T> and requires (based_t<T> t)
{
//	requires N_arity == 2;
	requires equality_p<2, T>;
	{_std::abs(t)} -> is_q<unvalue_t<T>>;
	{t.real()}     -> is_q<unvalue_t<T>>;
	{t.imag()}     -> is_q<unvalue_t<T>>;
};
template <size_t N_arity, class T, class U=T>
concept simplex_field_p = plex_field_p<N_arity, T> and not complex_field_p<N_arity, T>;


////////////////////////////////////////////////////////////////////////////////

template <class T>
XTAL_FN2 lateral_f(T n)
XTAL_0EX
{
	return n;
}
template <class T>
XTAL_FN2 lateral_f(T n, T m, auto ...ms)
XTAL_0EX
{
	auto constexpr N_count = 1 + 1 + sizeof...(ms);
	auto constexpr N_width = sizeof(T)/N_count;
	auto constexpr N_depth = N_width << 3;
	static_assert(N_width*N_count == sizeof(T));
	return lateral_f<T>(m|(n<<N_depth), ms...);
}

template <class T, auto ...Ms>
using lateral = constant<lateral_f<T>(Ms...)>;


}//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
