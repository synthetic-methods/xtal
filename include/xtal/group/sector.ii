#pragma once
#include "./any.ii"
#include "./lattice.ii"
#include "./scalar.ii"




XTAL_ENV_(push)
namespace xtal::group
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <class ..._s> XTAL_NYM sector;
template <class ..._s> XTAL_USE sector_t = typename sector<_s...>::type;
template <class ...Ts> XTAL_ASK sector_q = bond::tagged_p<sector, Ts...>;


////////////////////////////////////////////////////////////////////////////////
///\
Extends `lattice` with pointwise addition. \

///\note\
Represents the `dual_t` of `scalar_t`. \

template <class U, size_t N>
struct sector<U[N]>
{
	using re = bond::realize<U>;
	
	template <class T>
	using demitype = typename lattice<U[N]>::template homotype<T>;

	template <class T>
	using hemitype = bond::compose_s<demitype<T>, bond::tag<sector>>;

	template <class T>
	class homotype: public hemitype<T>
	{
		friend T;
		using S_ = hemitype<T>;
	
	public:
		using S_::S_;
		using S_::get;
		using S_::self;
		using S_::twin;

		template <class Z>
		using dual_t = typename scalar<U[N]>::type;

		XTAL_OP1_(T &) += (T const &t) XTAL_0EX {return bond::seek_forward_f<N>([&, this] (auto i) XTAL_0FN_(get(i) += t.get(i))), self();}
		XTAL_OP1_(T &) -= (T const &t) XTAL_0EX {return bond::seek_forward_f<N>([&, this] (auto i) XTAL_0FN_(get(i) -= t.get(i))), self();}

		template <subarray_q<N> Y> XTAL_OP1_(T &) += (Y const &w) XTAL_0EX {return bond::seek_forward_f<arity_n<XTAL_TYP_(w)>>([&, this] (auto i) XTAL_0FN_(get(i) += w[i])), self();}
		template <subarray_q<N> Y> XTAL_OP1_(T &) -= (Y const &w) XTAL_0EX {return bond::seek_forward_f<arity_n<XTAL_TYP_(w)>>([&, this] (auto i) XTAL_0FN_(get(i) -= w[i])), self();}

	};
	using type = bond::isotype<homotype>;

};


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
