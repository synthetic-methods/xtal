#pragma once
#include "./any.ii"
#include "./sluice.ii"





XTAL_ENV_(push)
namespace xtal::compound::fluid
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <class ..._s> XTAL_NYM siphon;
template <class ..._s> XTAL_USE siphon_t = typename siphon<_s...>::type;
template <class ...Ts> XTAL_ASK siphon_q = tag_p<siphon, Ts...>;


////////////////////////////////////////////////////////////////////////////////
///\

template <class A>
struct siphon<A>
{
	template <class T>
	using demitype = iterate_t<T>;

	template <class T>
	using hemitype = compose_s<demitype<T>, tag<siphon>>;

	template <class T>
	class homotype: public hemitype<T>
	{
		using S_ = hemitype<T>;

		using store_t = sluice_t<A>;
		using visor_t = typename store_t::iterator;
		using value_t = typename store_t::value_type;
		using count_t = typename store_t::difference_type;

		store_t m_store{};
		count_t n_begin = 0;
		count_t n_end   = 0;

	public:
		using S_::S_;
		
		///\note\
		The `size()` of the `std::initializer_list` determines the extent of lookup/lookahead. \

		XTAL_CON homotype(bracket_t<value_t> w)
		:	n_end {_std::distance(w.begin(), w.end())}
		,	m_store(w)
		{}

		XTAL_TO2_(XTAL_TN2     begin(count_t n=0), _std::next(m_store.begin(), n + n_begin))
		XTAL_TO2_(XTAL_TN2       end(count_t n=0), _std::prev(m_store.  end(), n + n_end))
		XTAL_TN2_(value_t &)    peek(count_t n=0) XTAL_0EX {              return *begin(n);}
		XTAL_TN1_(value_t &) advance(count_t n=1) XTAL_0EX {n_begin += n; return *begin(0);}
		XTAL_TN1_(value_t &) abandon(bool    n=1)
		XTAL_0EX
		{
			if (n) {
				n_begin = 0;
				clear();
			}
			return *begin();
		}
		XTAL_TN0 clear()
		XTAL_0EX
		{
			m_store.erase(m_store.begin(), end());
		}

		///\note\
		Cost can be amortized by invoking `advance` and `abandon` separately, \
		allowing for branchless `advance`ment. \

		XTAL_TN0 pop(visor_t i)
		XTAL_0EX
		{
			assert(i < end());
			n_begin -= i < begin();
			m_store.erase(i);
			abandon(begin() == end());
		}
		XTAL_TN0 pop()
		XTAL_0EX
		{
			advance();
			abandon(begin() == end());
		}
		XTAL_TN2_(visor_t) scan(XTAL_DEF w)
		XTAL_0EX
		{
			return _std::lower_bound(m_store.begin(), m_store.end()
			,	XTAL_REF_(w)
			);
		}
		XTAL_TN2_(visor_t) scan(XTAL_DEF w, XTAL_DEF f)
		XTAL_0EX
		{
			return _std::lower_bound(m_store.begin(), m_store.end()
			,	XTAL_REF_(w)
			,	[f = XTAL_REF_(f)] (XTAL_DEF x, XTAL_DEF y) XTAL_0FN_(f(x) < f(y))
			);
		}
		///\note\
		Conflicting entries w.r.t. `==` are overwritten. \

		XTAL_TN1_(visor_t) push(value_t v)
		XTAL_0EX
		{
			visor_t v_ = scan(v);
			if (*v_ == v) {
				_std::swap(*v_, v); return v_;
			}
			else {
				return poke(v_, XTAL_MOV_(v));
			}
		}
		template <is_q<value_t> W>
		XTAL_TN1_(visor_t) poke(visor_t v_, W &&w)
		XTAL_0EX
		{
			return m_store.insert(v_, XTAL_REF_(w));
		}
		XTAL_TN1_(visor_t) poke(visor_t v_, XTAL_DEF ...ws)
		XTAL_0EX
		{
			return m_store.insert(v_, value_t(XTAL_REF_(ws)...));
		}
		XTAL_TN1_(visor_t) poke(visor_t v_, XTAL_DEF ...ws)
		XTAL_0EX
		XTAL_REQ_(m_store.inplace(v_, XTAL_REF_(ws)...))
		{
			return m_store.inplace(v_, XTAL_REF_(ws)...);
		}

	};
	using type = _detail::isotype<homotype>;

};


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
