#pragma once
#include "./any.hh"






XTAL_ENV_(push)
namespace xtal::compound
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
///\
The following `subtype` decorators are specialized under each `xtal::*` namespace. \
They provide instance and proxy initialization/finalization for the generated types in `./any.hxx`. \


////////////////////////////////////////////////////////////////////////////////
///\
Expands on the `self`-reflection established by `../common/any.ipp#define`, \
providing the mechanism for traversing the trait-lineage of `T`. \

template <class T>
struct define
{
	using subkind = common::compose<_detail::define_member, _retail::define<T>>;
	
	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		using _S = common::compose_s<S, subkind>;
		using _Y = subkind;
	
	protected:
		using _0 = cardinal_t<0>;
		using _O = unit_t;
		///\
		Resolves the query/answer `X` w.r.t. the supplied context. \

		template <class X, typename ...Is> struct node:  _S::template node< X, Is...> {};
		template <class X, typename ...Is> struct node<X,  T, Is...>: node< T, Is...> {};
		template <class X, typename ...Is> struct node<X, _0, Is...>: node<_O, Is...> {};
	//	template <class X, typename ...Is> struct node<X, _0, Is...>;
		template <class X                > struct node<X> {using type = X;};

		template <class X, typename ...Is>
		using node_t = typename node<X, Is...>::type;
		using node_u = unit_t;

	public:
		using _S::_S;
	//	using _S::self;

		template <typename ...Is> using self_t =          node_t< T, Is...>;
	//	template <typename ...Is> using head_t = typename node_t<_Y, Is...>::head_u;

		XTAL_TO4_(
		XTAL_TN2 self(), _S::self()
		)
		XTAL_TO4_(template <of_q<subtype> X=T>
		XTAL_TN2 self(), _S::template self<X>()
		)
		///<\returns `this` as `T`, or `of_q<subtype>`. \
		
		
		XTAL_DO4_(template <typename ...Is>
		XTAL_TN2 self(XTAL_DEF... oo),
		{
			using X = node_t<T, Is...>;
			if constexpr (0 == sizeof...(oo)) {
				return _S::template self<X>();
			}
			else {
				return _S::template self<X>() = X(XTAL_REF_(oo)..., XTAL_MOV_(self()));
			}
		})
		///<\returns `this` indexed by `Is...`, \
		emplacing the matching part of `self` if arguments are supplied. \

		//\
		Trivial (in)equality. \
		
		XTAL_OP2_(bool) == (subtype const &t) XTAL_0FX {return true;}
		XTAL_OP2_(bool) != (subtype const &t) XTAL_0FX {return not self().operator==(t.self());}
		XTAL_OP2 <=> (subtype const &t)
		XTAL_0FX
		{
			using is = _std::partial_ordering;
			return self().operator==(t.self())? is::equivalent: is::unordered;
		}

		XTAL_TN2 apple() XTAL_0FX {return common::pack_f();}
		///<\returns a tuple representation of `this`. \

		using arity = cardinal_t<0>;
		///< The `std::tuple_size` of `this`. \

	};
};
///\
Finalizes `T` via CRTP e.g. applying `std::view_interface`, \
binding `subtype` as the default target of `self`. \

template <class T>
struct refine
{
	using subkind = common::compose<void
	,	_detail::refine_head
	,	_detail::refine_tuple
	>;

	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		using _S = common::compose_s<S, subkind>;
	
	public:
		using _S::_S;

	};
	template <any_q S> requires iterable_q<S>
	class subtype<S>: public common::compose_s<S, subkind>, public iterate_t<T>
	{
		using _S = common::compose_s<S, subkind>;
	
	public:
		using _S::_S;

	};
};


///////////////////////////////////////////////////////////////////////////////
///\
Proxies the given `U` via `head`, \
providing chained/tupled construction/access. \

///\note\
Mutable `lvalue`s are converted to pointers, \
providing a similar level of utility to `std::reference_wrapper`. \

template <class U>
struct defer
{
	using subkind = _detail::defer_member<U>;

	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		using _S = common::compose_s<S, subkind>;
		using _T = typename _S::self_u;
		using _Y = subtype;
		using _0 = cardinal_t<0>;

	protected:
		///\
		Resolves the query/answer `X` w.r.t. the supplied context. \

		template <class X, typename ...Is> struct node:  _S::template node< X, Is...> {};
		template <class X, typename ...Is> struct node<X, _Y, Is...>: node<_Y, Is...> {};
		template <class X, typename ...Is> struct node<X,  U, Is...>: node<_Y, Is...> {};
		template <class X, typename ...Is> struct node<X, _0, Is...>: node<_Y, Is...> {};
		template <class X, liminal_q N, typename ...Is>
		struct node<X, N, Is...>: _S::template node<typename _S::node_u, subliminal_s<N>, Is...> {};

		template <class X, typename ...Is>
		using node_t = typename node<X, Is...>::type;
		using node_u = subtype;
		
	public:
		using _S::_S;
		using _S::self;
		using _S::head;
		using head_u = typename _S::head_u;

		template <typename ...Is> using self_t =          node_t<_T, Is...>;
		template <typename ...Is> using head_t = typename node_t<_Y, Is...>::head_u;

		XTAL_TO4_(template <size_t I>
		XTAL_TN2 self(XTAL_DEF ...oo), self<cardinal_t<I>>(XTAL_REF_(oo)...)
		)		
		XTAL_TO4_(template <typename ...Is>
		XTAL_TN2 self(XTAL_DEF ...oo), _S::template self<node_t<S, Is...>>(XTAL_REF_(oo)...)
		)
		
		///\
		Converts `this` to the base-type (explicit). \

		XTAL_TO4_(XTAL_OP1_(explicit) head_u(), head())

		///\returns the kernel-body (prior to reconstruction using the given arguments, if provided). \

		XTAL_TO4_(template <class  ...Is> requires some_q<Is...>
		XTAL_TN1 head(XTAL_DEF... oo), self<Is...>().head(XTAL_REF_(oo)...)
		)
		XTAL_TO4_(template <size_t ...Is> requires some_n<Is...>
		XTAL_TN1 head(XTAL_DEF... oo), head<cardinal_t<Is>...>(XTAL_REF_(oo)...)
		)
		///\
		\returns `true` if the supplied body matches `head`, `false` otherwise. \

		XTAL_TN2_(bool) heading(head_u const &w)
		XTAL_0FX
		{
			return equivalent_f(head(), w);
		}
		///\
		Equality testing. \
		\returns `true` if the supplied body matches `this`, `false` otherwise. \

		XTAL_OP2_(bool) == (subtype const &t)
		XTAL_0FX
		{
			return heading(t.head()) and self<1>() == t;
		}

	//	XTAL_OP2 << (XTAL_DEF_(any_q) t) XTAL_0FX {return common::pack_f(XTAL_REF_(self()), XTAL_REF_(t));}
	//	XTAL_OP2 >> (XTAL_DEF_(any_q) t) XTAL_0FX {return common::pack_f(XTAL_REF_(self()), XTAL_REF_(t));}

		///\
		Tuple arity. \

		XTAL_USE arity = cardinal_t<_S::arity::value + 1>;
		///\
		Tuple application. \

		XTAL_TN2 apply(XTAL_DEF f)// TODO: Require `std::invocable`.
		XTAL_0FX
		{
			return [this, g = XTAL_REF_(f)] <size_t ...I>(common::seek_t<I...>)
				XTAL_0FN_(g(head<I>()...)) (common::seek_f<arity::value> {});
		}
		///\
		Tuple conversion (via `apply`). \

		XTAL_TN2 apple()
		XTAL_0FX
		{
		//	return apply(common::pack_f);
			return apply([] (XTAL_DEF ...oo) XTAL_0FN_(_std::make_tuple(XTAL_REF_(oo)...)));
		}

	};
};
///\
Defers selected operators to `U` as required for `refine`ment. \

template <class U>
struct refer: common::compose<void
,	_detail::refer_logics<U>
,	_detail::refer_groups<U>
,	_detail::refer_iterators<U>
,	_detail::refer_qualities<U>
>
{
};


////////////////////////////////////////////////////////////////////////////////

template <any_q W> XTAL_OP2 == (W const &x, W const &y) XTAL_0EX {return x.self().operator== (y.self());}
template <any_q W> XTAL_OP2 != (W const &x, W const &y) XTAL_0EX {return x.self().operator!= (y.self());}
template <any_q W> XTAL_OP2 <=>(W const &x, W const &y) XTAL_0EX {return x.self().operator<=>(y.self());}


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////

namespace std
{////////////////////////////////////////////////////////////////////////////

template <xtal::compound::any_q T>
struct tuple_size<T>: xtal::cardinal_t<T::arity::value> {};

template <size_t N, xtal::compound::any_q T>
struct tuple_element<N, T> {using type = XTAL_TYP_(XTAL_VAL_(T).template head<N>());};

template <size_t N, xtal::compound::any_q T> XTAL_TN1 get(T const &&t) {return std::move(t).template head<N>();};
template <size_t N, xtal::compound::any_q T> XTAL_TN1 get(T       &&t) {return std::move(t).template head<N>();};
template <size_t N, xtal::compound::any_q T> XTAL_TN1 get(T const  &t) {return t.template head<N>();};
template <size_t N, xtal::compound::any_q T> XTAL_TN1 get(T        &t) {return t.template head<N>();};


}//////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
