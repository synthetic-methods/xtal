#pragma once
#include <concepts>
#include <cassert>
#include <numbers>
#include <variant>
#include <cstring>
#include <cmath>
#include <tuple>
#include <array>
#include <queue>



#if __has_include(<execution>)
#include <execution>
#endif



#include <bit>
#if not __cpp_lib_bit_cast
namespace std
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <typename To, typename Fro>
requires (sizeof(To) == sizeof(Fro) and is_trivially_copyable_v<To> and is_trivially_copyable_v<Fro>)
static constexpr To bit_cast(Fro const& fro)
noexcept
{
	return __builtin_bit_cast(To, fro);
//	To to; memcpy(&to, &fro, sizeof(fro)); return to;
}

///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
#endif



#include <range/v3/all.hpp>
namespace xtal
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

namespace _std = ::std;
namespace _v3
{
namespace ranges = ::ranges;
namespace views  = ::ranges::views;
}

///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////



#include "../_.hpp"

#if XTAL_TRY__DEBUG// TODO: Use `fmt` or something for logging?
#include <iostream>
namespace xtal
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
struct
{
	decltype(auto) operator>> (auto&& w)
	{
		std::cout << '\n' << static_cast<decltype(w)&&>(w);
		return *this;
	}
	decltype(auto) operator<< (auto&& w)
	{
		std::cout << '\t' << static_cast<decltype(w)&&>(w);
		return *this;
	}
	void operator() (auto&&... ws)
	{
		(*this << ... << static_cast<decltype(ws)&&>(ws));
		std::cout << '\n';
	}

} ouch;
///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
#else
namespace xtal
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
struct
{
	decltype(auto) operator>> (auto&& w)
	{
	}
	decltype(auto) operator<< (auto&& w)
	{
	}
	void operator() (auto&&... ws)
	{
	}

} ouch;
///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
#endif

