#pragma once
#include "./any.ii"



#include "../process/any.hh"
#include "../processor/any.hh"

XTAL_ENV_(push)
namespace xtal::message
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

template <class ...Us> requires complete_q<Us...>
struct schedule
{
	XTAL_LET N_arity = sizeof...(Us);
	
	///\todo\
	Define `poll` (or adapt `hold` to provide the same functionality). \

	///\note\
	Dedicated implementation of message bundling required due to: \
	-	The use of `cue_s` to wrap `message`s by inheritance. \
	-	The need for unwrapping on dispatch (currently unsupported by the influx operator `<<=`). \

	using subkind = common::compose<defer<Us>...>;

	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		using S_ = common::compose_s<S, subkind>;
		using T_ = typename S_::self_t;
		using W_ = _std::tuple<Us...>;

	public:
		using S_::S_;
		///\todo\
		Define the tuple type (and other associated types) at the top level? \

		using event_u = conduct::cue_s<T_>;
		using delay_u = typename conduct::cue_s<>::head_t;

		///\
		Provides dispatch logic for `T_` on the target object. \

		template <class T>
		struct inqueued
		{
			template <process::any_q R>
			class subtype: public common::compose_s<R>
			{
				using R_ = common::compose_s<R>;
				
			public:
				using R_::R_;
				using R_::influx;

				///\
				Invokes `influx` immediately, \
				expanding the provided arguments. \
				
				XTAL_TLX influx(T_ o)
				XTAL_0EX
				{
					return influx(o.apple());
				}
				XTAL_TLX influx(W_ o)
				XTAL_0EX
				{
					return _std::apply([=, this] (Us ...us) XTAL_0FN_(influx(us...)), o);
				}

				///\
				Invokes `inqueue(event_u)` with the given argument. \

				XTAL_TLX influx(XTAL_DEF_(conduct::cue_q) dot)
				XTAL_0EX
				{
					(void) static_cast<T*>(this)->inqueue(XTAL_REF_(dot));
					return R_::influx();
				}

				///\
				Invokes `influx(event_u)` with the event constructed from the arguments. \

				XTAL_TLX influx(delay_u d_t, T_ o)
				XTAL_0EX
				{
					return influx(event_u(d_t, o));
				}
				XTAL_TLX influx(delay_u d_t, W_ o)
				XTAL_0EX
				{
					return _std::apply([=, this] (Us ...us) XTAL_0FN_(influx(d_t, us...)), o);
				}
				XTAL_TLX influx(delay_u d_t, Us ...us)
				XTAL_0EX
				{
					return influx(d_t, T_(us...));
				}

				XTAL_TLX influx(conduct::cue_s<> d_t, XTAL_DEF ...oo)
				XTAL_0EX
				{
					return influx(d_t.head(), XTAL_REF_(oo)...);
				}

			};
		};
		///\
		Provides a queue for `T_` on the target object, \
		scheduled via `influx` and processed in segments via `reflux`. \

		///\todo\
		Allow for scheduling beyond the current window, \
		possibly using `message::scope` to convert between absolute and relative delays. \

		template <int N_spool=-1>
		struct intermit
		{
			using spool_u = common::fluid::spool_t<event_u[(unsigned) N_spool]>;

			template <processor::any_q R>
			class subtype: public common::compose_s<R, inqueued<subtype<R>>>
			{
				using R_ = common::compose_s<R, inqueued<subtype<R>>>;
				spool_u q_{event_u::template sentry<1>()};

				XTAL_TO4_(XTAL_TN2 next_tail(), q_.peek().core())
				XTAL_TO4_(XTAL_TN2 next_head(), q_.peek().head())

			public:
				using R_::R_;
				using R_::self;
				using R_::influx;
				
				///\
				Invokes `influx` immediately if the given delay `dot == 0`, \
				otherwise enqueues the event `dot` at the specified index. \

				XTAL_TN0 inqueue(event_u dot)
				XTAL_0EX
				{
					if (0 == dot.head()) {
						(void) influx(dot.core());
					}
					else {
						q_.push(dot);
					}
				}

				///\returns The delay until the next event to be processed. \

				XTAL_TN1_(delay_u) delay()
				XTAL_0EX
				{
				//	NOTE: The `std::initializer_list` syntax voids segfaulting in `RELEASE`. \
				
					return _std::min<delay_u>({R_::delay(), next_head()});
				}
				///\
				Invokes `influx` for all events up-to the supplied delay `i`. \
				
				///\returns the delay until the next event. \

				XTAL_TN1_(delay_u) relay(delay_u i)
				XTAL_0EX
				{
					R_::relay(i);
					for (; 0 < q_.size() and next_head() <= i; q_.pop()) {
					//	R_::operator<<=(next_tail().apple());
						(void) influx(next_tail());
					}
					return delay();
				}

			};
		};
		///\
		Provides a queue for `T_` on the target object, \
		which is converted to a signal by successive calls to `method`. \

		template <int N_spool=-1> requires (1 == N_arity and 2 <= size_t(N_spool))
		struct hold
		{
			using spool_u = common::fluid::spool_t<event_u[(unsigned) N_spool]>;

			template <process::any_q R>
			class subtype: public common::compose_s<R, inqueued<subtype<R>>>
			{
				using R_ = common::compose_s<R, inqueued<subtype<R>>>;
				
				delay_u d_{0};
				spool_u q_{event_u::template sentry<-1>(), event_u::template sentry<+1>()};

			public:
				using R_::R_;

				XTAL_TN0 inqueue(event_u dot)
				XTAL_0EX
				{
					if (dot.head() < d_ and q_.empty()) {
						(void) q_.abandon().head(d_ = 0);
					}
					q_.push(XTAL_MOV_(dot));
				}

				XTAL_TN2 method()
				XTAL_0EX
				{
					return q_.advance(d_++ == q_.peek(1).head()).core().head();
				}

				///\todo\
				Use `T_=serial` to provide an incremental Dual pair, \
				replacing the first-derivative with the minimum w.r.t. the current difference. \
				\
				Should be straightforward to parameterize with e.g. `<K_ramping=0>`, \
				respectively enabling/disabling if the goal has/hasn't been met. \

				///\todo\
				Once the phasor-type is settled, define a `method` that updates only on reset. \

				///\todo\
				Override immediate-dispatch `influx` to enqueue the current value? \

			};
		};

	};
};
template <class ...Us>
using schedule_t = confined_t<schedule<Us...>>;


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
