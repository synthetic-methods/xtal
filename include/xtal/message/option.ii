#pragma once
#include "./any.ii"

#include "./delimit.ii"




XTAL_ENV_(push)
namespace xtal::message
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
///\
Taggable `option` set, intended to be `confined` prior to use. \

template <typename ...As>
struct option
{
	class cardinal: public common::seek_cardinal_t<As...> {};

	XTAL_LET_(size_t) N_depth = common::computer::bit_ceiling_f(cardinal::value);
	XTAL_LET_(size_t) N_width = size_t(1) << N_depth;
	XTAL_LET_(size_t) M_width = N_width - 1;

	static_assert(N_width == cardinal::value);// for now...
	
	template <class S>
	using demikind = common::compose<common::tag<option>, message::delimit<N_width>>;
	
	template <class S>
	using semikind = common::compose<common::tab<option>, message::delimit<N_width + S::limit()>>;
	
	struct subkind
	{
		template <class S>// base-type
		class subtype: public common::compose_s<S, demikind<S>>
		{
			using _S = common::compose_s<S, demikind<S>>;

		public:
		//	using _S::_S;

			XTAL_CO0_(subtype)
			XTAL_CO4_(subtype)
			
			XTAL_CXN subtype(XTAL_DEF ...oo)
			XTAL_0EX
			:	_S(XTAL_REF_(oo)...)
			{};
			
			template <common::tag_q<option> U>
			XTAL_CXN subtype(U &&u)
			XTAL_0EX
			{};

			template <class T>
			XTAL_TN2 get()
			XTAL_0EX
			{
				return 0;
			}
			
		};
		template <common::tag_q<option> S>// derived-type
		class subtype<S>: public common::compose_s<S, semikind<S>>
		{
			using _S = common::compose_s<S, semikind<S>>;

		public:
			using _S::_S;

		};
	};
	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		using _S = common::compose_s<S, subkind>;
	
	public:
		using _S::_S;

		using value_type = unsigned int;
		value_type value:N_width;

		XTAL_CO0_(subtype)
		XTAL_CO4_(subtype)

		XTAL_CXN subtype(XTAL_DEF ...oo)
		XTAL_0EX
		:	_S(XTAL_REF_(oo)...)
		{};
		template <_std::integral U>
		XTAL_CON subtype(U &&u)
		XTAL_0EX
		:	value(size_t(u)&M_width)
		,	_S(size_t(u) >> N_depth)
		{};
		template <cardinal_q U>
		XTAL_CON subtype(U &&u)
		XTAL_0EX
		:	subtype(XTAL_REF_(u))
		{};
		template <common::tag_q<option> U>
		XTAL_CXN subtype(U &&u)
		XTAL_0EX
		:	value(0)
		,	_S(XTAL_REF_(u))
		{};
		template <common::tag_q<option> U> requires common::tab_p<option, U>
		XTAL_CXN subtype(U &&u)
		XTAL_0EX
		:	value(u.template get<cardinal>().value)
		,	_S(XTAL_REF_(u))
		{};
		
		template <cardinal_q T>
		XTAL_TN2 get()
		XTAL_0EX
		{
			if constexpr (is_q<cardinal, T>) {
				return value;
			}
			else {
				return _S::template get<T>();
			}
		}
		template <typename A> requires (cardinal_q<typename A::cardinal> and not cardinal_q<A>)
		XTAL_TN2 get()
		XTAL_0EX
		{
			return get<typename A::cardinal>();
		}
		
	};
	template <class S>
	using is = logical_t<common::tab_q<S, option>>;

};
template <>
struct option<>
{
	template <class S>
	using is = logical_t<common::tag_q<S, option>>;

};
template <class T, typename ...As>
concept option_q = option<As...>::template is<T>::value;


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
