//////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//\
Structural...

///\
Defines a factory for the supplied type. \

template <class F>
XTAL_LET invoke_f = [] (auto &&...oo)
XTAL_0FN
{
	XTAL_IF0
	XTAL_0IF XTAL_REQ_TO_(F   {XTAL_REF_(oo)...})
	XTAL_0IF XTAL_REQ_TO_(F   (XTAL_REF_(oo)...))
	XTAL_0IF XTAL_REQ_TO_(F{} (XTAL_REF_(oo)...))
};
template <class F>
XTAL_USE invoke_t = decltype(invoke_f<F>);

template <class T>
XTAL_DEF_(return,inline)
XTAL_FN1 devolve_f(T &t)
XTAL_0EX
{
	return reinterpret_cast<devolve_t<_std::remove_reference_t<T>> &>(t);
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//\
Ranged...

template <int N_offset=0, class T>
XTAL_DEF_(return,inline)
XTAL_LET endpoint_f(T &&t)
XTAL_0EX
{
	if constexpr (iterator_q<T>) {
		XTAL_IF0
		XTAL_0IF (0 == N_offset) {return XTAL_REF_(t);}
		XTAL_0IF (0 != N_offset) {return _xtd::ranges::prev(XTAL_REF_(t), N_offset);}
	}
	else {
		XTAL_IF0
		XTAL_0IF (0 <= N_offset) {return point_f<N_offset>(_xtd::ranges::  end(XTAL_REF_(t)));}
		XTAL_0IF (N_offset <  0) {return point_f<N_offset>(_xtd::ranges::begin(XTAL_REF_(t)));}
	}
}
template <int N_offset=0, class T>
XTAL_DEF_(return,inline)
XTAL_LET point_f(T &&t)
XTAL_0EX
{
	if constexpr (iterator_q<_std::decay_t<T>>) {
		XTAL_IF0
		XTAL_0IF (0 == N_offset) {return XTAL_REF_(t);}
		XTAL_0IF (0 != N_offset) {return _xtd::ranges::next(XTAL_REF_(t), N_offset);}
	}
	else {
		XTAL_IF0
		XTAL_0IF (0 <= N_offset) {return point_f<N_offset>(_xtd::ranges::begin(XTAL_REF_(t)));}
		XTAL_0IF (N_offset <  0) {return point_f<N_offset>(_xtd::ranges::  end(XTAL_REF_(t)));}
	}
}
///\returns the `size` of the given range. \

///\note\
If provided with an `iota_view`, \
returns a `value_type` instead of `size_type` which is twice the width. \

template <class        ...Us>	XTAL_DEF_(return,inline) XTAL_FN1 count_f(_std::tuple<Us...>) XTAL_0EX {return sizeof...(Us);}
template <class U, size_t N >	XTAL_DEF_(return,inline) XTAL_FN1 count_f(_std::array<U,  N>) XTAL_0EX {return size_t(N);}
template <class U, class  V >	XTAL_DEF_(return,inline) XTAL_FN1 count_f(_std:: pair<U,  V>) XTAL_0EX {return size_t(2);}
template <class U           > XTAL_DEF_(return,inline) XTAL_FN1 count_f(_std::initializer_list<U> t) XTAL_0EX {return count_f(_std::array{XTAL_REF_(t)});}
XTAL_DEF_(return,inline)
XTAL_LET count_f(auto const &t)
XTAL_0EX -> size_t
{
	XTAL_IF0
	XTAL_0IF XTAL_REQ_TO_(static_cast<size_t>(t.size()))
	XTAL_0IF XTAL_REQ_TO_(static_cast<size_t>(t))
	XTAL_0IF XTAL_REQ_TO_(static_cast<size_t>(0))
}
XTAL_DEF_(return,inline)
XTAL_LET count_f(auto const &...ts)
XTAL_0EX -> size_t
{
	return _std::min<size_t>({(count_f(ts) - size_1)...}) + size_1;
}
XTAL_DEF_(return,inline) XTAL_FN1  account_f(auto const &...ts) XTAL_0EX {return _xtd::ranges::views::take(count_f(ts...));}
XTAL_DEF_(return,inline) XTAL_FN1 discount_f(auto const &...ts) XTAL_0EX {return _xtd::ranges::views::drop(count_f(ts...));}


template <counter_q  I >	XTAL_FN2 counted_f(I i0, I iN) XTAL_0EX {return counted_t<I>(i0, iN);}
template <class      T >	XTAL_FN2 counted_f(T &&t)      XTAL_0EX {return counted_t<T>(XTAL_REF_(t));}
template <class      T >	XTAL_FN2 counter_f(T &&t)      XTAL_0EX {return counter_t<T>(XTAL_REF_(t));}


///\returns the result of zipping `...xs` with `f`. \

template <class F             > XTAL_DEF_(inline) XTAL_LET iterative_f(F &&f            ) XTAL_0EX {return _xtd::ranges::views::      generate(XTAL_REF_(f)                  );}
template <class F, class    X > XTAL_DEF_(inline) XTAL_LET iterative_f(F &&f, X  &&   x ) XTAL_0EX {return _xtd::ranges::views::     transform(XTAL_REF_(x), XTAL_REF_(f)    );}
template <class F, class ...Xs> XTAL_DEF_(inline) XTAL_LET iterative_f(F &&f, Xs &&...xs) XTAL_0EX {return _xtd::ranges::views:: zip_transform(XTAL_REF_(f), XTAL_REF_(xs)...);}
template <class F, class ...Xs> XTAL_DEF_(inline) XTAL_LET iterative_f(       Xs &&...xs) XTAL_0EX {return                          iterative_f(invoke_f<F>, XTAL_REF_(xs)...);}


template <class T> XTAL_DEF_(inline) XTAL_FN1  objective_f(T &&t) XTAL_0EX_TO_(XTAL_REF_(t));
template <class T> XTAL_DEF_(inline) XTAL_FN1 subjective_f(T &&t) XTAL_0EX_TO_(XTAL_REF_(t));


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//\
Arithmetic...

template <class X, class Y>
XTAL_FN2 equal_f(X const &x, Y const &y)
XTAL_0EX
{
	return false;
}
template <class X, class Y> requires common_q<X, Y>
XTAL_FN2 equal_f(X const &x, Y const &y)
XTAL_0EX
{
	return x == y;
}
template <class X, class Y> requires iterable_q<X, Y> and epimorphic_q<X, Y>
XTAL_FN2 equal_f(X &&x, Y &&y)
XTAL_0EX
{
	return _xtd::ranges::equal(XTAL_REF_(x), XTAL_REF_(y));
}

template <class X, class Y>
XTAL_FN2 equivalent_f(X &&x, Y &&y)
XTAL_0EX
{
	return equal_f(XTAL_REF_(x), XTAL_REF_(y));
}
template <class X, class Y> requires iterable_q<X, Y> and isomorphic_q<X, Y>
XTAL_FN2 equivalent_f(X const &x, Y const &y)
XTAL_0EX
{
	XTAL_IF0
	XTAL_0IF XTAL_REQ_TO_(&x == &y or x.begin() == y.begin() and x.end() == y.end())
	XTAL_0IF XTAL_REQ_TO_(&x == &y or x.begin() == y.begin())
	XTAL_0IF XTAL_REQ_TO_(&x == &y)
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#if not XTAL_SIC
class
{
public:
	XTAL_OP1() (auto &&...xs)
	{
		if constexpr (0 < sizeof...(xs)) {
			return (XTAL_REF_(xs), ...);
		}
	}

} echo;
#else
class
{
	XTAL_TN0 print_list(auto &&x)
	XTAL_0FX
	{
		for (auto &&w: XTAL_REF_(x)) ::std::cout << XTAL_REF_(w) << '\t';
	}
	XTAL_TN0 print_item(auto &&x)
	XTAL_0FX
	{
		using W = XTAL_TYP_(x);
		if constexpr (::std::is_floating_point_v<W>) {
			::std::cout.precision(17);
		}
		if constexpr (::std::is_arithmetic_v<W>) {
			if (::std::copysign(1.0, x) == 1.0) {
				 ::std::cout << ' ';
			}
		}
		::std::cout << XTAL_REF_(x) << '\t';
	}
	XTAL_TN1 put(auto &&x)
	XTAL_0FX
	{
		using W = XTAL_TYP_(x);
		if constexpr (_xtd::ranges::range<W> and requires {::std::is_arithmetic_v<typename W::value_type>;}) {
			print_list(XTAL_REF_(x));
		}
		else {
			print_item(XTAL_REF_(x));
		}
		return XTAL_REF_(x);
	}

public:
	XTAL_OP1() (auto &&...xs)
	XTAL_0FX
	{
		if constexpr (0 < sizeof...(xs)) {
			::std::cout << '\t'; auto const x = (put(XTAL_REF_(xs)), ...);
			::std::cout << '\n';
			return x;
		}
		else {
			::std::cout << '\n';
		}
	}

} const echo;
#endif


///////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
