#pragma once
#include "./any.ii"

#include "../message/packet.ii"
#include "../process/any.hh"
#include "../processor/any.hh"
#include "../resource/all.ii"

XTAL_ENV_(push)
namespace xtal::schedule
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

///\
Provides an (in)queue for `X` on the target object, \
which is converted to a signal by successive calls to `method`. \

///\todo\
Adapt to provide polling. \

template <typename ...As>
struct sampled
{
	using subkind = common::compose<As..., resource::spooled<-1>>;

	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		using S_ = common::compose_s<S, subkind>;
		static_assert(resource::spooled_q<S_>);

	public:
		using S_::S_;

		template <class X>
		struct inqueue
		{
			using subkind = typename S_::template inqueue<X>;

			template <process::any_q R>
			class subtype: public common::compose_s<R, subkind>
			{
				using R_ = common::compose_s<R, subkind>;
			
			protected:
				using typename R_::V_tuple;
				using typename R_::U_tuple;
				using typename R_::U_event;
				using typename R_::U_delay;
				using U_spool = typename S_::template spool_t<U_event>;

				U_delay d_{0};
				U_spool q_{U_event::template sentry<-1>(), U_event::template sentry<1>()};

			public:
				using R_::R_;

				XTAL_TN0 ingest(U_event dot)
				XTAL_0EX
				{
					if (dot.head() < d_ and q_.empty()) {
						(void) q_.abandon().head(d_ = 0);
					}
					q_.push(XTAL_MOV_(dot));
				}

				XTAL_TN2 method()
				XTAL_0EX
				{
					return q_.advance(d_++ == q_.peek(1).head()).core().head();
				}

				///\todo\
				Use `U_tuple=serial` to provide an incremental Dual pair, \
				replacing the first-derivative with the minimum w.r.t. the current difference. \
				\
				Should be straightforward to parameterize with e.g. `<N_ramping=0>`, \
				respectively enabling/disabling if the goal has/hasn't been met. \

				///\todo\
				Once the phasor-type is settled, define a `method` that updates only on reset. \

				///\todo\
				Override immediate-dispatch `influx` to enqueue the current value? \

			};
		};

	};
};
template <class X>
using sampled_t = confined_t<sampled<X>>;


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
