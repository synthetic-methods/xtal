#pragma once
#include "./any.ii"

#include "../message/packet.ii"
#include "../process/any.hh"
#include "../processor/any.hh"
#include "../resource/all.ii"

XTAL_ENV_(push)
namespace xtal::schedule
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
///\
Provides an (in)queue for `Xs...` on the target object, \
scheduled via `influx` and processed in segments via `reflux`. \

///\todo\
Allow for scheduled beyond the current window, \
possibly using `message::scope` to convert between absolute and relative delays. \

template <typename ...As>
struct spliced
{
	using subkind = atom::compose<As..., resource::spooled<-1>>;

	template <any_q S>
	class subtype: public atom::compose_s<S, subkind>
	{
		using S_ = atom::compose_s<S, subkind>;
		static_assert(resource::spooled_q<S_>);

	public:
		using S_::S_;
		
		template <class ...Xs>
		struct inqueue
		{
			using subkind = typename S_::template inqueue<Xs...>;
			
			template <processor::any_q R>
			class subtype: public atom::compose_s<R, subkind>
			{
				using R_ = atom::compose_s<R, subkind>;

			protected:
				using typename R_::V_tuple;
				using typename R_::U_tuple;
				using typename R_::U_event;
				using typename R_::U_delay;
				using U_spool = typename S_::template spool_t<U_event>;

				U_spool __spool {U_event::template sentry<1>()};

				XTAL_TO4_(XTAL_TN2 next_core(), __spool.peek().core())
				XTAL_TO4_(XTAL_TN2 next_head(), __spool.peek().head())

			public:
				using R_::R_;
				using R_::self;
				using R_::influx;
				
				///\
				Invokes `influx` immediately if the given delay `u_event == 0`, \
				otherwise enqueues the event `u_event` at the specified index. \

				XTAL_TN0 ingest(U_event u_event)
				XTAL_0EX
				{
					if (0 == u_event.head()) {
						(void) influx(u_event.core());
					}
					else {
						__spool.push(u_event);
					}
				}

				///\returns The delay until the next event to be processed. \

				XTAL_TN1_(U_delay) delay()
				XTAL_0EX
				{
				//	NOTE: The `std::initializer_list` syntax voids segfaulting in `RELEASE`. \
				
					return _std::min<U_delay>({R_::delay(), next_head()});
				}
				///\
				Invokes `influx` for all events up-to the supplied delay `i`. \
				
				///\returns the delay until the next event. \

				XTAL_TN1_(U_delay) relay(U_delay i)
				XTAL_0EX
				{
					R_::relay(i);
					for (; 0 < __spool.size() and next_head() <= i; __spool.pop()) {
					//	R_::operator<<=(next_core().apple());
						(void) influx(next_core());
					}
					return delay();
				}

			};
		};

	};
};
template <class ...Xs>
using spliced_t = confined_t<spliced<Xs...>>;


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
