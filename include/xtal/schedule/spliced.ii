#pragma once
#include "./any.ii"

#include "../message/packet.ii"
#include "../process/any.hh"
#include "../processor/any.hh"
#include "../resource/all.ii"

XTAL_ENV_(push)
namespace xtal::schedule
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
///\
Provides an (in)queue for `Xs...` on the target object, \
scheduled via `influx` and processed in segments via `reflux`. \

///\todo\
Allow for scheduled beyond the current window, \
possibly using `message::scope` to convert between absolute and relative delays. \

template <typename ...As>
struct spliced
{
	using subkind = common::compose<As..., resource::respool<-1>>;

	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		using _S = common::compose_s<S, subkind>;
		static_assert(resource::respool_q<_S>);

	public:
		using _S::_S;
		
		template <class ...Xs>
		struct inqueue
		{
			using subkind = typename _S::template inqueue<Xs...>;
			
			template <processor::any_q R>
			class subtype: public common::compose_s<R, subkind>
			{
				using _R = common::compose_s<R, subkind>;

			protected:
				using typename _R::tuple_t;
				using typename _R::tuple_u;
				using typename _R::event_u;
				using typename _R::delay_u;
				using spool_u = typename _S::template spool_t<event_u>;

				spool_u q_{event_u::template sentry<1>()};

				XTAL_TO4_(XTAL_TN2 next_tail(), q_.peek().core())
				XTAL_TO4_(XTAL_TN2 next_head(), q_.peek().head())

			public:
				using _R::_R;
				using _R::self;
				using _R::influx;
				
				///\
				Invokes `influx` immediately if the given delay `dot == 0`, \
				otherwise enqueues the event `dot` at the specified index. \

				XTAL_TN0 ingest(event_u dot)
				XTAL_0EX
				{
					if (0 == dot.head()) {
						(void) influx(dot.core());
					}
					else {
						q_.push(dot);
					}
				}

				///\returns The delay until the next event to be processed. \

				XTAL_TN1_(delay_u) delay()
				XTAL_0EX
				{
				//	NOTE: The `std::initializer_list` syntax voids segfaulting in `RELEASE`. \
				
					return _std::min<delay_u>({_R::delay(), next_head()});
				}
				///\
				Invokes `influx` for all events up-to the supplied delay `i`. \
				
				///\returns the delay until the next event. \

				XTAL_TN1_(delay_u) relay(delay_u i)
				XTAL_0EX
				{
					_R::relay(i);
					for (; 0 < q_.size() and next_head() <= i; q_.pop()) {
					//	_R::operator<<=(next_tail().apple());
						(void) influx(next_tail());
					}
					return delay();
				}

			};
		};

	};
};
template <class ...Xs>
using spliced_t = confined_t<spliced<Xs...>>;


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
