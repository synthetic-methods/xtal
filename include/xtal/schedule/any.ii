#pragma once
#include "./any.hh"






XTAL_ENV_(push)
namespace xtal::schedule
{/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

template <class T>
struct define
{
	using subkind = _retail::define<T>;

	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		friend T;
		using _S = common::compose_s<S, subkind>;
	
	public:
		using _S::_S;
		using _S::self;

		///\
		Provides dispatch logic for `Xs...` on the target object. \
		
		///\note\
		The naming is intended to reflect that only `influx` is queued/`cue`d. \

		template <class ...Xs>
		struct inqueue
		{
			template <process::any_q R>
			class subtype: public common::compose_s<R>
			{
				using _R = common::compose_s<R>;
				static_assert(complete_q<Xs...>);
				
			protected:
				using tuple_t = _std::tuple<Xs...>;
				using tuple_u = message::packet_t<Xs...>;
				using event_u = compound::cue_s<tuple_u>;
				using delay_u = typename compound::cue_s<>::head_u;

			public:
				using _R::_R;
				using _R::self;
				using _R::influx;

				///\
				Invokes `influx` immediately, \
				expanding the provided arguments. \
				
				XTAL_TLX influx(tuple_u o)
				XTAL_0EX
				{
					return influx(o.apple());
				}
				XTAL_TLX influx(tuple_t o)
				XTAL_0EX
				{
					return _std::apply([=, this] (Xs ...us) XTAL_0FN_(influx(us...)), o);
				}

				///\
				Invokes `ingest(event_u)` with the given argument. \

				XTAL_TLX influx(XTAL_DEF_(compound::cue_q) dot)
				XTAL_0EX
				{
					(void) self().ingest(XTAL_REF_(dot));
					return _R::influx();
				}

				///\
				Invokes `influx(event_u)` with the event constructed from the arguments. \

				XTAL_TLX influx(delay_u d_t, tuple_u o)
				XTAL_0EX
				{
					return influx(event_u(d_t, o));
				}
				XTAL_TLX influx(delay_u d_t, tuple_t o)
				XTAL_0EX
				{
					return _std::apply([=, this] (Xs ...us) XTAL_0FN_(influx(d_t, us...)), o);
				}
				XTAL_TLX influx(delay_u d_t, Xs ...us)
				XTAL_0EX
				{
					return influx(d_t, tuple_u(us...));
				}

				XTAL_TLX influx(compound::cue_s<> d_t, XTAL_DEF ...oo)
				XTAL_0EX
				{
					return influx(d_t.head(), XTAL_REF_(oo)...);
				}

			};
		};

	};
};
template <class T>
struct refine
{
	using subkind = _retail::refine<T>;

	template <any_q S>
	class subtype: public common::compose_s<S, subkind>
	{
		using _S = common::compose_s<S, subkind>;
	
		template <class ...Xs>
		using _F = typename _S::template inqueue<Xs...>;

	public:
		using _S::_S;
		using _S::self;

		template <class ...Xs>
		struct inqueue: _F<Xs...>
		{
			using kind = confined<_F<Xs...>>;
			using type = common::compose_s<_S, kind>;
		
		};
		template <class ...Xs>
		using inqueue_t = typename inqueue<Xs...>::type;

	};
};


////////////////////////////////////////////////////////////////////////////////

template <class U>
struct defer
:	_retail::defer<U>
{
};
template <class U>
struct refer
:	_retail::refer<U>
{
};


///////////////////////////////////////////////////////////////////////////////
}/////////////////////////////////////////////////////////////////////////////
XTAL_ENV_(pop)
